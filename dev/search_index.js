var documenterSearchIndex = {"docs":
[{"location":"internal/utils/","page":"utils.jl","title":"utils.jl","text":"CollapsedDocStrings = true","category":"page"},{"location":"internal/utils/#utils.jl","page":"utils.jl","title":"utils.jl","text":"","category":"section"},{"location":"internal/utils/#Public-functions","page":"utils.jl","title":"Public functions","text":"","category":"section"},{"location":"internal/utils/","page":"utils.jl","title":"utils.jl","text":"Modules = [QuantumACES]\nPages = [\"utils.jl\"]\nPrivate = false","category":"page"},{"location":"internal/utils/#QuantumACES.get_mapping_string-Union{Tuple{T}, Tuple{Mapping, T}} where T<:AbstractCircuit-internal-utils","page":"utils.jl","title":"QuantumACES.get_mapping_string","text":"get_mapping_string(m::Mapping, c::AbstractCircuit; two_qubit_only::Bool = false)\n\nReturns the string representation of the mapping m for the circuit c, including eigenvalues.\n\n\n\n\n\n","category":"method"},{"location":"internal/utils/#QuantumACES.get_pauli_string-Tuple{Pauli}-internal-utils","page":"utils.jl","title":"QuantumACES.get_pauli_string","text":"get_pauli_string(p::Pauli)\n\nReturns the string representation of the Pauli p.\n\n\n\n\n\n","category":"method"},{"location":"internal/utils/#QuantumACES.get_support-Tuple{Pauli}-internal-utils","page":"utils.jl","title":"QuantumACES.get_support","text":"get_support(p::Pauli)\n\nReturns the support of the Pauli p.\n\n\n\n\n\n","category":"method"},{"location":"internal/utils/#QuantumACES.pretty_print-Tuple{ACESData, Tuple{Merit, Merit, Merit}}-internal-utils","page":"utils.jl","title":"QuantumACES.pretty_print","text":"pretty_print(aces_data::ACESData, merit_set::Tuple{Merit, Merit, Merit})\n\nPrints the z-scores of the normalised RMS errors of the gate eigenvalue estimator vector for the GLS, WLS, and OLS estimators in aces_data using the predicted means and variances for each in merit_set.\n\n\n\n\n\n","category":"method"},{"location":"internal/utils/#QuantumACES.pretty_print-Tuple{Design}-internal-utils","page":"utils.jl","title":"QuantumACES.pretty_print","text":"pretty_print(d::Design)\n\nPrints the tuple set and shot weight data of the design d in a readable format.\n\n\n\n\n\n","category":"method"},{"location":"internal/utils/#QuantumACES.pretty_print-Tuple{Matrix{Float64}}-internal-utils","page":"utils.jl","title":"QuantumACES.pretty_print","text":"pretty_print(merit_array::Matrix{Float64})\n\nPrints merit_array, produced by compare_ls_optimise_weights, in a readable format.\n\n\n\n\n\n","category":"method"},{"location":"internal/utils/#Private-functions","page":"utils.jl","title":"Private functions","text":"","category":"section"},{"location":"internal/utils/","page":"utils.jl","title":"utils.jl","text":"Modules = [QuantumACES]\nPages = [\"utils.jl\"]\nPublic = false","category":"page"},{"location":"internal/utils/#QuantumACES.project_simplex-Tuple{Vector{Float64}}","page":"utils.jl","title":"QuantumACES.project_simplex","text":"project_simplex(probabilities::Vector{Float64})\n\nReturns a copy of the probability distribution probabilities projected into the probability simplex according to the Euclidean norm.\n\n\n\n\n\n","category":"method"},{"location":"internal/utils/#QuantumACES.wht_matrix-Tuple{Int64}","page":"utils.jl","title":"QuantumACES.wht_matrix","text":"wht_matrix(n::Int)\n\nReturns the symplectically ordered Walsh-Hadamard transform matrix of order n, which maps an n-qubit Pauli error probability distribution to its eigenvalues. The inverse transform is obtained by dividing the transform by the factor 4^n.\n\n\n\n\n\n","category":"method"},{"location":"internal/tableau/","page":"tableau.jl","title":"tableau.jl","text":"CollapsedDocStrings = true","category":"page"},{"location":"internal/tableau/#tableau.jl","page":"tableau.jl","title":"tableau.jl","text":"","category":"section"},{"location":"internal/tableau/#Public-functions","page":"tableau.jl","title":"Public functions","text":"","category":"section"},{"location":"internal/tableau/","page":"tableau.jl","title":"tableau.jl","text":"Modules = [QuantumACES]\nPages = [\"tableau.jl\"]\nPrivate = false","category":"page"},{"location":"internal/tableau/#QuantumACES.Gate-internal-tableau","page":"tableau.jl","title":"QuantumACES.Gate","text":"Gate\n\nA gate in a stabiliser circuit.\n\nFields\n\ntype::String: String describing the gate type.\nindex::Int32: The index labelling the unique layer occurrences of the gate in a circuit.\ntargets::Vector{Int16}: The qubit targets of the gate.\n\nSupported gates\n\nH: Hadamard gate.\nS: Phase gate.\nCX or CNOT: Controlled-X gate.\nCZ: Controlled-Z gate.\nI: Identity gate.\nZ: Pauli Z gate.\nX: Pauli X gate.\nY: Pauli Y gate.\nII: Two-qubit identity gate.\nAB: Two-qubit Pauli gate, where A and B are Paulis Z, X, or Y.\nSQRT_AB: Two-qubit Pauli rotation, where A and B are Paulis Z, X, or Y.\nSQRT_AB_DAG : Two-qubit Pauli rotation, where A and B are Paulis Z, X, or Y.\nPZ+: Prepare the Pauli +Z eigenstate.\nPZ-: Prepare the Pauli -Z eigenstate.\nPX+: Prepare the Pauli +X eigenstate.\nPX-: Prepare the Pauli -X eigenstate.\nPY+: Prepare the Pauli +Y eigenstate.\nPY-: Prepare the Pauli -Y eigenstate.\nM or MZ: Measure in the computational Pauli Z basis.\nMX: Measure in the Pauli X basis.\nMY: Measure in the Pauli Y basis.\nR: Reset to the computational Z basis.\n\n\n\n\n\n","category":"type"},{"location":"internal/tableau/#QuantumACES.Layer-internal-tableau","page":"tableau.jl","title":"QuantumACES.Layer","text":"Layer\n\nA layer of gates in a stabiliser circuit. Gates in a layer are simultaneously implemented by the device, and act on disjoint sets of qubits such that they trivially commute with each other.\n\nFields\n\nlayer::Vector{Gate}: The gates in the layer.\nqubit_num::Int16: The number of qubits in the circuit.\n\n\n\n\n\n","category":"type"},{"location":"internal/tableau/#QuantumACES.Tableau-internal-tableau","page":"tableau.jl","title":"QuantumACES.Tableau","text":"Tableau\n\nA tableau representation of a stabiliser state.\n\nStabiliser circuit simulations follow Improved simulation of stabilizer circuits by S. Aaronson and D. Gottesman (2004).\n\nFields\n\ntableau::Matrix{Bool}: The tableau representation of the stabiliser state.\nqubit_num::Int16: The number of qubits in the stabiliser state.\n\n\n\n\n\n","category":"type"},{"location":"internal/tableau/#QuantumACES.apply!-Tuple{Tableau, Layer}-internal-tableau","page":"tableau.jl","title":"QuantumACES.apply!","text":"apply!(t::Tableau, l::Layer; return_measurements::Bool = false)\n\nPerform on the tableau t all gates in the layer l, and return the list of measurement outcomes if return_measurements is true.\n\n\n\n\n\n","category":"method"},{"location":"internal/tableau/#QuantumACES.make_layer-Tuple{String, Vector{Int64}, Int64}-internal-tableau","page":"tableau.jl","title":"QuantumACES.make_layer","text":"make_layer(gate_type::String, range::Vector{Int}, n::Int)\n\nReturns a layer of single-qubit gate_type gates acting on the qubits in range, where the layer acts on n qubits.\n\n\n\n\n\n","category":"method"},{"location":"internal/tableau/#QuantumACES.make_layer-Tuple{String, Vector{Vector{Int64}}, Int64}-internal-tableau","page":"tableau.jl","title":"QuantumACES.make_layer","text":"make_layer(gate_type::String, range_set::Vector{Vector{Int}}, n::Int)\n\nReturns a layer of gate_type gates, each acting on the qubits in range_set, where the layer acts on n qubits.\n\n\n\n\n\n","category":"method"},{"location":"internal/tableau/#QuantumACES.make_layer-Tuple{Vector{String}, Vector{Vector{Int64}}, Int64}-internal-tableau","page":"tableau.jl","title":"QuantumACES.make_layer","text":"make_layer(gate_types::Vector{String}, ranges::Vector{Vector{Int}}, n::Int)\n\nReturns a layer of single-qubit gates, with gate types specified by gate_types and the qubits upon which they act specified by ranges, where the layer acts on n qubits.\n\n\n\n\n\n","category":"method"},{"location":"internal/tableau/#QuantumACES.pad_layer-Tuple{Layer}-internal-tableau","page":"tableau.jl","title":"QuantumACES.pad_layer","text":"pad_layer(l::Layer)\n\nReturns a copy of the layer l padded by single-qubit identity gates that act on each of the qubits not already acted upon by some gate in the layer.\n\n\n\n\n\n","category":"method"},{"location":"internal/tableau/#Private-functions","page":"tableau.jl","title":"Private functions","text":"","category":"section"},{"location":"internal/tableau/","page":"tableau.jl","title":"tableau.jl","text":"Modules = [QuantumACES]\nPages = [\"tableau.jl\"]\nPublic = false","category":"page"},{"location":"internal/tableau/#QuantumACES.cx!-Tuple{Tableau, Integer, Integer}","page":"tableau.jl","title":"QuantumACES.cx!","text":"cx!(t::Tableau, control::Integer, target::Integer)\n\nPerform a controlled-X gate on the tableau t with control qubit control and target qubit target.\n\n\n\n\n\n","category":"method"},{"location":"internal/tableau/#QuantumACES.cz!-Tuple{Tableau, Integer, Integer}","page":"tableau.jl","title":"QuantumACES.cz!","text":"cz!(t::Tableau, control::Integer, target::Integer)\n\nPerform a controlled-Z gate on the tableau t with control qubit control and target qubit target. The gate is symmetric, so the control and target qubits can be swapped.\n\n\n\n\n\n","category":"method"},{"location":"internal/tableau/#QuantumACES.hadamard!-Tuple{Tableau, Integer}","page":"tableau.jl","title":"QuantumACES.hadamard!","text":"hadamard!(t::Tableau,target::Integer)\n\nPerform a Hadamard gate on the tableau t with target qubit target.\n\n\n\n\n\n","category":"method"},{"location":"internal/tableau/#QuantumACES.measure!-Tuple{Tableau, Integer}","page":"tableau.jl","title":"QuantumACES.measure!","text":"measure!(t::Tableau, target::Integer)\n\nMeasure the tableau t at the target qubit target, and return the measurement outcome.\n\n\n\n\n\n","category":"method"},{"location":"internal/tableau/#QuantumACES.phase!-Tuple{Tableau, Integer}","page":"tableau.jl","title":"QuantumACES.phase!","text":"phase!(t::Tableau,target::Integer)\n\nPerform a phase gate on the tableau t with target qubit target.\n\n\n\n\n\n","category":"method"},{"location":"internal/tableau/#QuantumACES.reset!-Tuple{Tableau, Integer}","page":"tableau.jl","title":"QuantumACES.reset!","text":"reset!(t::Tableau, target::Integer)\n\nReset the tableau t at the target qubit target by measuring in the computational basis and flipping the phase if the measurement outcome is -1.\n\n\n\n\n\n","category":"method"},{"location":"internal/tableau/#QuantumACES.row_phase-NTuple{4, Bool}","page":"tableau.jl","title":"QuantumACES.row_phase","text":"row_phase(x₁::Bool, z₁::Bool, x₂::Bool, z₂::Bool)\n\nCalculate a phase for row_sum!.\n\n\n\n\n\n","category":"method"},{"location":"internal/tableau/#QuantumACES.row_sum!-Tuple{Tableau, Integer, Integer}","page":"tableau.jl","title":"QuantumACES.row_sum!","text":"row_sum!(t::Tableau, target::Integer, control::Integer)\n\nIn the tableau t, add the control row control to the target row target, while tracking the phase bit of the target row.\n\n\n\n\n\n","category":"method"},{"location":"internal/tableau/#QuantumACES.sqrt_zz!-Tuple{Tableau, Integer, Integer}","page":"tableau.jl","title":"QuantumACES.sqrt_zz!","text":"sqrt_zz!(t::Tableau, control::Integer, target::Integer)\n\nPerform a π/2 ZZ Pauli rotation gate on the tableau t with control qubit control and target qubit target. The gate is symmetric, so the control and target qubits can be swapped.\n\n\n\n\n\n","category":"method"},{"location":"internal/tableau/#QuantumACES.sqrt_zz_dag!-Tuple{Tableau, Integer, Integer}","page":"tableau.jl","title":"QuantumACES.sqrt_zz_dag!","text":"sqrt_zz_dag!(t::Tableau, control::Integer, target::Integer)\n\nPerform a -π/2 ZZ Pauli rotation gate on the tableau t with control qubit control and target qubit target. The gate is symmetric, so the control and target qubits can be swapped.\n\n\n\n\n\n","category":"method"},{"location":"internal/tableau/#QuantumACES.x!-Tuple{Tableau, Integer}","page":"tableau.jl","title":"QuantumACES.x!","text":"x!(t::Tableau,target::Integer)\n\nPerform a Pauli X gate on the tableau t with target qubit target, noting that X = H S^2 H.\n\n\n\n\n\n","category":"method"},{"location":"internal/tableau/#QuantumACES.y!-Tuple{Tableau, Integer}","page":"tableau.jl","title":"QuantumACES.y!","text":"y!(t::Tableau,target::Integer)\n\nPerform a Pauli Z gate on the tableau t with target qubit target, noting that Y = S H S^2 H S^3.\n\n\n\n\n\n","category":"method"},{"location":"internal/tableau/#QuantumACES.z!-Tuple{Tableau, Integer}","page":"tableau.jl","title":"QuantumACES.z!","text":"z!(t::Tableau,target::Integer)\n\nPerform a Pauli Z gate on the tableau t with target qubit target, noting that Z = S^2.\n\n\n\n\n\n","category":"method"},{"location":"internal/QuantumACES/","page":"QuantumACES.jl","title":"QuantumACES.jl","text":"CollapsedDocStrings = true","category":"page"},{"location":"internal/QuantumACES/#QuantumACES.jl","page":"QuantumACES.jl","title":"QuantumACES.jl","text":"","category":"section"},{"location":"internal/QuantumACES/#Public-functions","page":"QuantumACES.jl","title":"Public functions","text":"","category":"section"},{"location":"internal/QuantumACES/","page":"QuantumACES.jl","title":"QuantumACES.jl","text":"Modules = [QuantumACES]\nPages = [\"QuantumACES.jl\"]\nPrivate = false","category":"page"},{"location":"internal/QuantumACES/#QuantumACES.QuantumACES-internal-QuantumACES","page":"QuantumACES.jl","title":"QuantumACES.QuantumACES","text":"QuantumACES.jl is a package for designing and simulating scalable and performant Pauli noise characterisation experiments for stabiliser circuits with averaged circuit eigenvalue sampling (ACES). It is particularly interested in characterising the noise associated with fault-tolerant gadgets in the context of topological quantum error correcting codes, such as surface code syndrome extraction circuits.\n\n\n\n\n\n","category":"module"},{"location":"internal/QuantumACES/#QuantumACES.AbstractCircuit-internal-QuantumACES","page":"QuantumACES.jl","title":"QuantumACES.AbstractCircuit","text":"AbstractCircuit\n\nCircuits should be stored in a subtype T <: AbstractCircuit.\n\nCircuits should be generated by a method of get_circuit, and prepare_circuit is a helpful function for writing such a method.\n\nNecessary fields\n\ncircuit_param::AbstractCircuitParameters: Circuit parameters.\ncircuit::Vector{Layer}: Circuit arranged by the tuple.\ncircuit_tuple::Vector{Int}: Tuple which arranges the order of the circuit layers; this is initialised as trivial.\nqubit_num::Int: Number of qubits in the circuit.\nunique_layer_indices::Vector{Int}: Unique layer indices of the circuit, which become meaningless and are removed the circuit is arranged by the tuple.\nlayer_types::Vector{Symbol}: Types of the layers in the circuit, used for layer times and dynamical decoupling.\nlayer_times::Vector{Float64}: Times taken to implement each layer in the circuit, as well as measurement and reset.\ngates::Vector{Gate}: Gates in the circuit arranged by the tuple.\ntotal_gates::Vector{Gate}: Gates in the original circuit, which includes noisy preparations if add_prep and noisy measurements if add_meas.\ngate_index::Dict{Gate, Int}: Index of the gate eigenvalues for each gates in the original circuit.\nN::Int: Number of gate eigenvalues.\nnoise_param::AbstractNoiseParameters: Noise parameters.\ngate_probabilities::Dict{Gate, Vector{Float64}}: Pauli error probabilities for each gate, stored as a dictionary.\ngate_eigenvalues::Vector{Float64}: Eigenvalues for each gate, stored as a vector whose order is determined by gate_index.\nadd_prep::Bool: Whether to treat preparations as noisy and characterise the associated noise, which should default to false; a full-rank design cannot be produced if both add_prep and add_meas are true.\nadd_meas::Bool: Whether to treat measurements as noisy and characterise the associated noise, which should default to true; a full-rank design cannot be produced if both add_prep and add_meas are true.\n\nOptional fields\n\npartition::Tuple{Vector{Int}, Vector{Int}}: A partition of the qubits into two sets such that two-qubit gates act only between the sets, which allows for easy preparation of sign configurations for Pauli eigenstates; for example, data and ancilla qubits for a syndrome extraction circuit.\n\n\n\n\n\n","category":"type"},{"location":"internal/QuantumACES/#QuantumACES.AbstractCircuitParameters-internal-QuantumACES","page":"QuantumACES.jl","title":"QuantumACES.AbstractCircuitParameters","text":"AbstractCircuitParameters\n\nCircuit parameters should be stored in a subtype T <: AbstractCircuitParameters.\n\nThen add a method to get_circuit that generates a circuit according to these parameters. Such a circuit should either be a Circuit type, or a subtype T <: AbstractCircuit.\n\nNecessary fields\n\nlayer_time_dict::Dict{Symbol, Float64}: Dictionary of the times taken to implement the different types of layers in the circuit, including the time for measurement and reset.\ncircuit_name::String: Name of the circuit, which should implicitly describe parameter settings.\n\n\n\n\n\n","category":"type"},{"location":"internal/QuantumACES/#QuantumACES.AbstractNoiseParameters-internal-QuantumACES","page":"QuantumACES.jl","title":"QuantumACES.AbstractNoiseParameters","text":"AbstractNoiseParameters\n\nNoise parameters should be stored in a subtype T <: AbstractNoiseParameters.\n\nNoise models should be generated by a method of get_gate_probabilities, which generates Pauli error probabilities for the supplied gates according to some supplied noise parameters.\n\nNecessary fields\n\nnoise_name::String: Name of the noise model, which should implicitly describe parameter settings.\n\n\n\n\n\n","category":"type"},{"location":"internal/QuantumACES/#QuantumACES.AbstractScalingData-internal-QuantumACES","page":"QuantumACES.jl","title":"QuantumACES.AbstractScalingData","text":"AbstractScalingData\n\nScaling data for the figure of merit should be stored in a subtype T <: AbstractScalingData.\n\nNecessary fields\n\ncircuit_param::AbstractCircuitParameters: Circuit parameters.\nnoise_param::AbstractNoiseParameters: Noise parameters.\ntuple_set::Vector{Vector{Int}}: Set of tuples which arrange the circuit layers.\ntuple_set_data::TupleSetData: TupleSetData object that generates the tuple set.\nshot_weights::Vector{Float64}: Shot weights for each tuple in the set, which add to 1.\nls_type::Symbol: Type of least squares estimator for which the scaling is calculated.\n\n\n\n\n\n","category":"type"},{"location":"internal/QuantumACES/#Private-functions","page":"QuantumACES.jl","title":"Private functions","text":"","category":"section"},{"location":"internal/QuantumACES/","page":"QuantumACES.jl","title":"QuantumACES.jl","text":"Modules = [QuantumACES]\nPages = [\"QuantumACES.jl\"]\nPublic = false","category":"page"},{"location":"internal/circuit/","page":"circuit.jl","title":"circuit.jl","text":"CollapsedDocStrings = true","category":"page"},{"location":"internal/circuit/#circuit.jl","page":"circuit.jl","title":"circuit.jl","text":"","category":"section"},{"location":"internal/circuit/#Public-functions","page":"circuit.jl","title":"Public functions","text":"","category":"section"},{"location":"internal/circuit/","page":"circuit.jl","title":"circuit.jl","text":"Modules = [QuantumACES]\nPages = [\"circuit.jl\"]\nPrivate = false","category":"page"},{"location":"internal/circuit/#QuantumACES.Circuit-internal-circuit","page":"circuit.jl","title":"QuantumACES.Circuit","text":"Circuit\n\nCircuit information, including noise parameters.\n\nFields\n\ncircuit_param::AbstractCircuitParameters: Circuit parameters.\ncircuit::Vector{Layer}: Circuit arranged by the tuple.\ncircuit_tuple::Vector{Int}: Tuple which arranges the order of the circuit layers; this is initialised as trivial.\nqubit_num::Int: Number of qubits in the circuit.\nunique_layer_indices::Vector{Int}: Unique layer indices of the circuit, which become meaningless and are removed the circuit is arranged by the tuple.\nlayer_types::Vector{Symbol}: Types of the layers in the circuit, used for layer times and dynamical decoupling.\nlayer_times::Vector{Float64}: Times taken to implement each layer in the circuit, as well as measurement and reset.\ngates::Vector{Gate}: Gates in the circuit arranged by the tuple.\ntotal_gates::Vector{Gate}: Gates in the original circuit, which includes noisy preparations if add_prep and noisy measurements if add_meas.\ngate_index::Dict{Gate, Int}: Index of the gate eigenvalues for each gates in the original circuit.\nN::Int: Number of gate eigenvalues.\nnoise_param::AbstractNoiseParameters: Noise parameters.\ngate_probabilities::Dict{Gate, Vector{Float64}}: Pauli error probabilities for each gate, stored as a dictionary.\ngate_eigenvalues::Vector{Float64}: Eigenvalues for each gate, stored as a vector whose order is determined by gate_index.\nadd_prep::Bool: Whether to treat preparations as noisy and characterise the associated noise, defaulting to false; a full-rank design cannot be produced if both add_prep and add_meas are true.\nadd_meas::Bool: Whether to treat measurements as noisy and characterise the associated noise, defaulting to true; a full-rank design cannot be produced if both add_prep and add_meas are true.\n\n\n\n\n\n","category":"type"},{"location":"internal/circuit/#QuantumACES.RotatedPlanarCircuit-internal-circuit","page":"circuit.jl","title":"QuantumACES.RotatedPlanarCircuit","text":"RotatedPlanarCircuit\n\nSyndrome extraction circuit for a rotated surface code.\n\nFields\n\ncircuit_param::RotatedPlanarParameters: Circuit parameters.\ncircuit::Vector{Layer}: Circuit arranged by the tuple.\ncircuit_tuple::Vector{Int}: Tuple which arranges the order of the circuit layers; this is initialised as trivial.\nqubit_num::Int: Number of qubits in the circuit.\nunique_layer_indices::Vector{Int}: Unique layer indices of the circuit, which become meaningless and are removed the circuit is arranged by the tuple.\nlayer_types::Vector{Symbol}: Types of the layers in the circuit, used for layer times and dynamical decoupling.\nlayer_times::Vector{Float64}: Times taken to implement each layer in the circuit, as well as measurement and reset.\ngates::Vector{Gate}: Gates in the circuit arranged by the tuple.\ntotal_gates::Vector{Gate}: Gates in the original circuit, which includes noisy preparations if add_prep and noisy measurements if add_meas.\ngate_index::Dict{Gate, Int}: Index of the gate eigenvalues for each gates in the original circuit.\nN::Int: Number of gate eigenvalues.\nnoise_param::AbstractNoiseParameters: Noise parameters.\ngate_probabilities::Dict{Gate, Vector{Float64}}: Pauli error probabilities for each gate, stored as a dictionary.\ngate_eigenvalues::Vector{Float64}: Eigenvalues for each gate, stored as a vector whose order is determined by gate_index.\nadd_prep::Bool: Whether to treat preparations as noisy and characterise the associated noise, defaulting to false; a full-rank design cannot be produced if both add_prep and add_meas are true.\nadd_meas::Bool: Whether to treat measurements as noisy and characterise the associated noise, defaulting to true; a full-rank design cannot be produced if both add_prep and add_meas are true.\npartition::Tuple{Vector{Int}, Vector{Int}}: Partition of the qubits (data, ancilla), allowing for easy preparation of sign configurations for Pauli eigenstates.\nqubits::Vector{Tuple{Int, Int}}: Code qubit lattice locations.\ninverse_indices::Dict{Tuple{Int, Int}, Int}: Inverse mapping from the qubit lattice locations to their indices.\ndata_indices::Vector{Int}: Data qubit indices.\nancilla_indices::Vector{Int}: Ancilla qubit indices.\nancilla_X_indices::Vector{Int}: Ancilla X-check qubit indices.\nancilla_Z_indices::Vector{Int}: Ancilla Z-check qubit indices.\nqubit_layout::Matrix{String}: Diagram of the layout of the code qubits.\n\n\n\n\n\n","category":"type"},{"location":"internal/circuit/#QuantumACES.RotatedPlanarParameters-internal-circuit","page":"circuit.jl","title":"QuantumACES.RotatedPlanarParameters","text":"RotatedPlanarParameters\n\nParameters for the syndrome extraction circuit of a rotated surface code.\n\nFields\n\nvertical_dist::Int: Vertical (Z) distance of the code.\nhorizontal_dist::Int: Horizontal (X) distance of the code.\ncheck_type::Symbol: Type of stabiliser used in the circuit, either :xzzx or :standard.\ngate_type::Symbol: Type of two-qubit gate used in the circuit, either :cx or :cz.\ndynamically_decouple::Bool: Whether to dynamically decouple the circuit; true is currently only supported for :xzzx and :cz.\npad_identity::Bool: Whether to pad layers with single-qubit identity gates.\nlayer_time_dict::Dict{Symbol, Float64}: Dictionary of layer times.\ncircuit_name::String: Name of the circuit used for saving data.\n\n\n\n\n\n","category":"type"},{"location":"internal/circuit/#QuantumACES.UnrotatedPlanarCircuit-internal-circuit","page":"circuit.jl","title":"QuantumACES.UnrotatedPlanarCircuit","text":"UnrotatedPlanarCircuit\n\nSyndrome extraction circuit for a unrotated surface code.\n\nFields\n\ncircuit_param::UnrotatedPlanarParameters: Circuit parameters.\ncircuit::Vector{Layer}: Circuit arranged by the tuple.\ncircuit_tuple::Vector{Int}: Tuple which arranges the order of the circuit layers; this is initialised as trivial.\nqubit_num::Int: Number of qubits in the circuit.\nunique_layer_indices::Vector{Int}: Unique layer indices of the circuit, which become meaningless and are removed the circuit is arranged by the tuple.\nlayer_types::Vector{Symbol}: Types of the layers in the circuit, used for layer times and dynamical decoupling.\nlayer_times::Vector{Float64}: Times taken to implement each layer in the circuit, as well as measurement and reset.\ngates::Vector{Gate}: Gates in the circuit arranged by the tuple.\ntotal_gates::Vector{Gate}: Gates in the original circuit, which includes noisy preparations if add_prep and noisy measurements if add_meas.\ngate_index::Dict{Gate, Int}: Index of the gate eigenvalues for each gates in the original circuit.\nN::Int: Number of gate eigenvalues.\nnoise_param::AbstractNoiseParameters: Noise parameters.\ngate_probabilities::Dict{Gate, Vector{Float64}}: Pauli error probabilities for each gate, stored as a dictionary.\ngate_eigenvalues::Vector{Float64}: Eigenvalues for each gate, stored as a vector whose order is determined by gate_index.\nadd_prep::Bool: Whether to treat preparations as noisy and characterise the associated noise, defaulting to false; a full-rank design cannot be produced if both add_prep and add_meas are true.\nadd_meas::Bool: Whether to treat measurements as noisy and characterise the associated noise, defaulting to true; a full-rank design cannot be produced if both add_prep and add_meas are true.\npartition::Tuple{Vector{Int}, Vector{Int}}: Partition of the qubits (data, ancilla), allowing for easy preparation of sign configurations for Pauli eigenstates.\nqubits::Vector{Tuple{Int, Int}}: Code qubit lattice locations.\ninverse_indices::Dict{Tuple{Int, Int}, Int}: Inverse mapping from the qubit lattice locations to their indices.\ndata_indices::Vector{Int}: Data qubit indices.\nancilla_indices::Vector{Int}: Ancilla qubit indices.\nancilla_X_indices::Vector{Int}: Ancilla X-check qubit indices.\nancilla_Z_indices::Vector{Int}: Ancilla Z-check qubit indices.\nqubit_layout::Matrix{String}: Diagram of the layout of the code qubits.\n\n\n\n\n\n","category":"type"},{"location":"internal/circuit/#QuantumACES.UnrotatedPlanarParameters-internal-circuit","page":"circuit.jl","title":"QuantumACES.UnrotatedPlanarParameters","text":"UnrotatedPlanarParameters\n\nParameters for the syndrome extraction circuit of an unrotated surface code.\n\nFields\n\nvertical_dist::Int: Vertical (Z) distance of the code.\nhorizontal_dist::Int: Horizontal (X) distance of the code.\ngate_type::Symbol: Type of two-qubit gate used in the circuit, which must be :cx.\npad_identity::Bool: Whether to pad layers with single-qubit identity gates.\nlayer_time_dict::Dict{Symbol, Float64}: Dictionary of layer times.\ncircuit_name::String: Name of the circuit used for saving data.\n\n\n\n\n\n","category":"type"},{"location":"internal/circuit/#QuantumACES.get_circuit-Union{Tuple{T}, Tuple{RotatedPlanarParameters, T}} where T<:AbstractNoiseParameters-internal-circuit","page":"circuit.jl","title":"QuantumACES.get_circuit","text":"get_circuit(rotated_param::RotatedPlanarParameters, noise_param::AbstractNoiseParameters; kwargs...)\nget_circuit(unrotated_param::UnrotatedPlanarParameters, noise_param::AbstractNoiseParameters; kwargs...)\n\nReturns a circuit object, a subtype T <: AbstractCircuit, parameterised by the supplied circuit and noise parameters.\n\nArguments\n\nrotated_param::RotatedPlanarParameters: Parameters for a rotated surface code.\nunrotated_param::UnrotatedPlanarParameters: Parameters for an unrotated surface code.\nnoise_param::AbstractNoiseParameters: Noise parameters for the circuit.\n\nKeyword arguments\n\nadd_prep::Bool = false: Whether to treat preparations as noisy and characterise the associated noise, defaulting to false; a full-rank design cannot be produced if both add_prep and add_meas are true.\nadd_meas::Bool = true: Whether to treat measurements as noisy and characterise the associated noise, defaulting to true; a full-rank design cannot be produced if both add_prep and add_meas are true.\n\n\n\n\n\n","category":"method"},{"location":"internal/circuit/#QuantumACES.get_layer_times-Tuple{Vector{Symbol}, Dict{Symbol, Float64}}-internal-circuit","page":"circuit.jl","title":"QuantumACES.get_layer_times","text":"get_layer_times(layer_types::Vector{Symbol}, layer_time_dict::Dict{Symbol, Float64})\n\nReturns the times taken to implement each layer in the circuit based on their types in layer_types and the times specified in `layertimedict, including the time for measurement and reset at the end.\n\n\n\n\n\n","category":"method"},{"location":"internal/circuit/#QuantumACES.get_rotated_param-Tuple{Int64, Int64}-internal-circuit","page":"circuit.jl","title":"QuantumACES.get_rotated_param","text":"get_rotated_param(vertical_dist::Int, horizontal_dist::Int; kwargs...)\nget_rotated_param(dist::Int; kwargs...)\n\nReturns a RotatedPlanarParameters object that parameterises the syndrome extraction circuit of a rotated surface code.\n\nDefault gate layer times are estimated from Suppressing quantum errors by scaling a surface code logical qubit by Google Quantum AI (2023).\n\nArguments\n\nvertical_dist::Int: Vertical (Z) distance of the code.\nhorizontal_dist::Int: Horizontal (X) distance of the code.\ndist::Int: Distance of the code; this is equivalent to setting vertical_dist = dist and horizontal_dist = dist.\n\nKeyword arguments\n\ncheck_type::Symbol = :xzzx: Type of stabiliser used in the circuit, either :xzzx or :standard.\ngate_type::Symbol = :cz: Type of two-qubit gate used in the circuit, either :cx or :cz.\ndynamically_decouple::Bool = true: Whether to dynamically decouple the circuit; true is currently only supported for :xzzx and :cz.\npad_identity::Bool = true: Whether to pad layers with single-qubit identity gates.\nsingle_qubit_time::Float64 = 29.0: Time taken to implement a single-qubit gate in nanoseconds.\ntwo_qubit_time::Float64 = 29.0: Time taken to implement a two-qubit gate in nanoseconds.\nmeas_reset_time::Float64 = 660.0: Time taken to perform measurement and reset at the end of the circuit in nanoseconds.\ndynamical_decoupling_time::Float64 = 29.0: Time taken to implement a dynamical decoupling layer in nanoseconds.\n\n\n\n\n\n","category":"method"},{"location":"internal/circuit/#QuantumACES.get_unrotated_param-Tuple{Int64, Int64}-internal-circuit","page":"circuit.jl","title":"QuantumACES.get_unrotated_param","text":"get_unrotated_param(vertical_dist::Int, horizontal_dist::Int; kwargs...)\nget_unrotated_param(dist::Int; kwargs...)\n\nReturns an UnrotatedPlanarParameters object that parameterises the syndrome extraction circuit of a unrotated surface code.\n\nDefault gate layer times are estimated from Suppressing quantum errors by scaling a surface code logical qubit by Google Quantum AI (2023).\n\nArguments\n\nvertical_dist::Int: Vertical (Z) distance of the code.\nhorizontal_dist::Int: Horizontal (X) distance of the code.\ndist::Int: Distance of the code; this is equivalent to setting vertical_dist = dist and horizontal_dist = dist.\n\nKeyword arguments\n\ngate_type::Symbol = :cx: Type of two-qubit gate used in the circuit, which must be :cx.\npad_identity::Bool = true: Whether to pad layers with single-qubit identity gates.\nsingle_qubit_time::Float64 = 29.0: Time taken to implement a single-qubit gate in nanoseconds.\ntwo_qubit_time::Float64 = 29.0: Time taken to implement a two-qubit gate in nanoseconds.\ndynamical_decoupling_time::Float64 = 29.0: Time taken to implement a dynamical decoupling layer in nanoseconds.\nmeas_reset_time::Float64 = 660.0: Time taken to perform measurement and reset at the end of the circuit in nanoseconds.\n\n\n\n\n\n","category":"method"},{"location":"internal/circuit/#QuantumACES.prepare_circuit-Union{Tuple{T}, Tuple{Vector{Layer}, Int64, Vector{Symbol}, Vector{Float64}, T}} where T<:AbstractNoiseParameters-internal-circuit","page":"circuit.jl","title":"QuantumACES.prepare_circuit","text":"prepare_circuit(circuit::Vector{Layer}, qubit_num::Int, layer_types::Vector{Symbol}, layer_times::Vector{Float64}, noise_param::AbstractNoiseParameters; add_prep::Bool = false, add_meas::Bool = true)\n\nReturns a labelled copy of the circuit as well as a number of required fields for subtypes T <: AbstractCircuit.\n\nArguments\n\ncircuit::Vector{Layer}: Circuit.\nqubit_num::Int: Number of qubits in the circuit.\nlayer_types::Vector{Symbol}: Types of the layers in the circuit.\nlayer_times::Vector{Float64}: Times taken to implement each layer in the circuit, including measurement and reset at the end.\nnoise_param::AbstractNoiseParameters: Noise parameters.\n\nKeyword arguments\n\nadd_prep::Bool = false: Whether to treat preparations as noisy and aim to characterise them.\nadd_meas::Bool = true: Whether to treat measurements as noisy and aim to characterise them.\n\nReturns\n\ncircuit::Vector{Layer}: Circuit with labelled gates.\nunique_layer_indices::Vector{Int}: Indices of the unique layers in the circuit.\ngates::Vector{Gate}: Gates in the circuit.\ntotal_gates::Vector{Gate}: Total gates in the circuit, including preparations if add_prep and measurements if add_meas.\ngate_index::Dict{Gate, Int}: Index of the gate eigenvalues for each gate in the original circuit.\nN::Int: Number of gate eigenvalues.\ngate_probabilities::Dict{Gate, Vector{Float64}}: Pauli error probabilities for each gate, stored as a dictionary.\ngate_eigenvalues::Vector{Float64}: Eigenvalues for each gate, stored as a vector whose order is determined by gate_index.\n\n\n\n\n\n","category":"method"},{"location":"internal/circuit/#QuantumACES.update_noise-Union{Tuple{U}, Tuple{T}, Tuple{T, U}} where {T<:AbstractCircuit, U<:AbstractNoiseParameters}-internal-circuit","page":"circuit.jl","title":"QuantumACES.update_noise","text":"update_noise(c::AbstractCircuit, noise_param::AbstractNoiseParameters)\n\nReturns a copy of c where the circuit has been updated with noise generated according to noise_param.\n\n\n\n\n\n","category":"method"},{"location":"internal/circuit/#Private-functions","page":"circuit.jl","title":"Private functions","text":"","category":"section"},{"location":"internal/circuit/","page":"circuit.jl","title":"circuit.jl","text":"Modules = [QuantumACES]\nPages = [\"circuit.jl\"]\nPublic = false","category":"page"},{"location":"internal/circuit/#QuantumACES.apply_tuple-Union{Tuple{T}, Tuple{T, Vector{Int64}}} where T<:AbstractCircuit","page":"circuit.jl","title":"QuantumACES.apply_tuple","text":"apply_tuple(c::AbstractCircuit, circuit_tuple::Vector{Int})\n\nReturns a copy of the circuit c arranged by the tuple circuit_tuple.\n\n\n\n\n\n","category":"method"},{"location":"internal/circuit/#QuantumACES.get_gates-Tuple{Vector{Vector{Gate}}}","page":"circuit.jl","title":"QuantumACES.get_gates","text":"get_gates(circuit::Vector{Vector{Gate}})\nget_gates(circuit::Vector{Layer})\n\nReturns the unique gates in the circuit circuit.\n\n\n\n\n\n","category":"method"},{"location":"internal/circuit/#QuantumACES.index_gates-Tuple{Vector{Gate}, Integer, Bool, Bool}","page":"circuit.jl","title":"QuantumACES.index_gates","text":"index_gates(gates::Vector{Gate}, n::Integer, add_prep::Bool, add_meas::Bool)\n\nReturns a dictionary indexing the gates in gates, adding preparations and measurements on all n qubits to the gates add_prep and add_meas are true, respectively, as well as the total collection of gates once these have been added and the number of gate eigenvalues.\n\n\n\n\n\n","category":"method"},{"location":"internal/circuit/#QuantumACES.label_circuit-Tuple{Vector{Vector{Gate}}}","page":"circuit.jl","title":"QuantumACES.label_circuit","text":"label_circuit(circuit::Vector{Vector{Gate}})\nlabel_circuit(circuit::Vector{Layer})\n\nReturns a labelled copy of the circuit circuit, with indices indicating the unique layer appearances of each gate in the circuit. This function should only be applied to the original circuit before it is arranged by a tuple.\n\n\n\n\n\n","category":"method"},{"location":"internal/circuit/#QuantumACES.rotated_planar_circuit-Tuple{RotatedPlanarParameters}","page":"circuit.jl","title":"QuantumACES.rotated_planar_circuit","text":"rotated_planar_circuit(rotated_param::RotatedPlanarParameters)\n\nReturns fields used to construct the syndrome extraction circuit of a rotated surface code in the form of a RotatedPlanarCircuit object, based on the supplied parameters rotated_param.\n\n\n\n\n\n","category":"method"},{"location":"internal/circuit/#QuantumACES.unrotated_planar_circuit-Tuple{UnrotatedPlanarParameters}","page":"circuit.jl","title":"QuantumACES.unrotated_planar_circuit","text":"unrotated_planar_circuit(unrotated_param::UnrotatedPlanarParameters)\n\nReturns fields used to construct the syndrome extraction circuit of an unrotated surface code in the form of a UnrotatedPlanarCircuit object, based on the supplied parameters unrotated_param.\n\n\n\n\n\n","category":"method"},{"location":"internal/circuit/#QuantumACES.unwrap_circuit-Tuple{Vector{Layer}}","page":"circuit.jl","title":"QuantumACES.unwrap_circuit","text":"unwrap_circuit(circuit::Vector{Layer})\n\nReturns a copy of the circuit circuit where each layer has been unwrapped into a vector of gates.\n\n\n\n\n\n","category":"method"},{"location":"internal/weights/","page":"weights.jl","title":"weights.jl","text":"CollapsedDocStrings = true","category":"page"},{"location":"internal/weights/#weights.jl","page":"weights.jl","title":"weights.jl","text":"","category":"section"},{"location":"internal/weights/#Public-functions","page":"weights.jl","title":"Public functions","text":"","category":"section"},{"location":"internal/weights/","page":"weights.jl","title":"weights.jl","text":"Modules = [QuantumACES]\nPages = [\"weights.jl\"]\nPrivate = false","category":"page"},{"location":"internal/weights/#QuantumACES.compare_ls_optimise_weights-Tuple{Design, SparseArrays.SparseMatrixCSC{Float64, Int64}}-internal-weights","page":"weights.jl","title":"QuantumACES.compare_ls_optimise_weights","text":"compare_ls_optimise_weights(d::Design, covariance_log::SparseMatrixCSC{Float64, Int}; gls_options::OptimOptions = OptimOptions(; ls_type = :gls), wls_options::OptimOptions = OptimOptions(; ls_type = :wls), ols_options::OptimOptions = OptimOptions(; ls_type = :ols))\n\nReturns versions of the design d and circuit log-eigenvalue estimator covariance matrix covariance_log after optimising the shot weights with respect to the figure of merit, alongside the figure of merit values at each step and the final merits, for all three least squares estimator types. The optimisation for each is parameterised by the OptimOptions objects gls_options, wls_options, and ols_options, respectively.\n\n\n\n\n\n","category":"method"},{"location":"internal/weights/#QuantumACES.gls_optimise_weights-Tuple{Design, SparseArrays.SparseMatrixCSC{Float64, Int64}}-internal-weights","page":"weights.jl","title":"QuantumACES.gls_optimise_weights","text":"gls_optimise_weights(d::Design, covariance_log::SparseMatrixCSC{Float64, Int}; options::OptimOptions = OptimOptions())\n\nReturns versions of the design d and circuit log-eigenvalue estimator covariance matrix covariance_log after optimising the shot weights with respect to the generalised least squares (GLS) figure of merit, alongside the figure of merit values at each step. The optimisation is parameterised by the OptimOptions object options.\n\n\n\n\n\n","category":"method"},{"location":"internal/weights/#QuantumACES.ols_optimise_weights-Tuple{Design, SparseArrays.SparseMatrixCSC{Float64, Int64}}-internal-weights","page":"weights.jl","title":"QuantumACES.ols_optimise_weights","text":"ols_optimise_weights(d::Design, covariance_log::SparseMatrixCSC{Float64, Int}; options::OptimOptions = OptimOptions())\n\nReturns versions of the design d and circuit log-eigenvalue estimator covariance matrix covariance_log after optimising the shot weights with respect to the ordinary least squares (OLS) figure of merit, alongside the figure of merit values at each step. The optimisation is parameterised by the OptimOptions object options.\n\n\n\n\n\n","category":"method"},{"location":"internal/weights/#QuantumACES.optimise_weights-Tuple{Design, SparseArrays.SparseMatrixCSC{Float64, Int64}}-internal-weights","page":"weights.jl","title":"QuantumACES.optimise_weights","text":"optimise_weights(d::Design, covariance_log::SparseMatrixCSC{Float64, Int}; options::OptimOptions = OptimOptions())\n\nReturns versions of the design d and circuit log-eigenvalue estimator covariance matrix covariance_log after optimising the shot weights with respect to the figure of merit, alongside the figure of merit values at each step. The optimisation is parameterised by the OptimOptions object options, which in particular specifies the least squares estimator type for which the figure of merit is calculated.\n\n\n\n\n\n","category":"method"},{"location":"internal/weights/#QuantumACES.wls_optimise_weights-Tuple{Design, SparseArrays.SparseMatrixCSC{Float64, Int64}}-internal-weights","page":"weights.jl","title":"QuantumACES.wls_optimise_weights","text":"wls_optimise_weights(d::Design, covariance_log::SparseMatrixCSC{Float64, Int}; options::OptimOptions = OptimOptions())\n\nReturns versions of the design d and circuit log-eigenvalue estimator covariance matrix covariance_log after optimising the shot weights with respect to the weighted least squares (WLS) figure of merit, alongside the figure of merit values at each step. The optimisation is parameterised by the OptimOptions object options.\n\n\n\n\n\n","category":"method"},{"location":"internal/weights/#Private-functions","page":"weights.jl","title":"Private functions","text":"","category":"section"},{"location":"internal/weights/","page":"weights.jl","title":"weights.jl","text":"Modules = [QuantumACES]\nPages = [\"weights.jl\"]\nPublic = false","category":"page"},{"location":"internal/weights/#QuantumACES.calc_gls_merit_grad_log-Tuple{Design, Vector{Float64}, SparseArrays.SparseMatrixCSC{Float64, Int64}}","page":"weights.jl","title":"QuantumACES.calc_gls_merit_grad_log","text":"calc_gls_merit_grad_log(d::Design, shot_weights::Vector{Float64}, covariance_log_unweighted_inv::SparseMatrixCSC{Float64, Int})\n\nReturns the gradient of the generalised least squares (GLS) figure of merit for the design d with respect to the logarithms of the shot weights shot_weights, using the inverse of the unweighted (by the shot weights factor) covariance matrix of the circuit log-eigenvalue estimator covariance_log_unweighted_inv.\n\n\n\n\n\n","category":"method"},{"location":"internal/weights/#QuantumACES.calc_ols_merit_grad_log-Tuple{Design, Vector{Float64}, Matrix{Float64}, Matrix{Float64}, Matrix{Float64}}","page":"weights.jl","title":"QuantumACES.calc_ols_merit_grad_log","text":"calc_ols_merit_grad_log(d::Design, shot_weights::Vector{Float64}, ols_estimator::Matrix{Float64}, ols_estimator_covariance::Matrix{Float64}, ols_gram_covariance::Matrix{Float64})\n\nReturns the gradient of the ordinary least squares (OLS) figure of merit for the design d with respect to the logarithms of the shot weights shot_weights, using the OLS estimator matrix ols_estimator, scaled by the unweighted covariance matrix in ols_estimator_covariance, and the OLS Gram matrix also scaled by the unweighted covariance matrix in ols_gram_covariance.\n\n\n\n\n\n","category":"method"},{"location":"internal/weights/#QuantumACES.calc_wls_merit_grad_log-Tuple{Design, Vector{Float64}, SparseArrays.SparseMatrixCSC{Float64, Int64}}","page":"weights.jl","title":"QuantumACES.calc_wls_merit_grad_log","text":"calc_wls_merit_grad_log(d::Design, shot_weights::Vector{Float64}, covariance_log_unweighted::SparseMatrixCSC{Float64, Int})\n\nReturns the gradient of the weighted least squares (WLS) figure of merit for the design d with respect to the logarithms of the shot weights shot_weights, using the unweighted (by the shot weights factor) covariance matrix of the circuit log-eigenvalue estimator covariance_log_unweighted.\n\n\n\n\n\n","category":"method"},{"location":"internal/weights/#QuantumACES.get_merit_grad-Tuple{Float64, Vector{Float64}, Float64, Vector{Float64}, Int64}","page":"weights.jl","title":"QuantumACES.get_merit_grad","text":"get_merit_grad(sigma_tr::Float64, sigma_tr_grad::Vector{Float64}, sigma_sq_tr::Float64, sigma_sq_tr_grad::Vector{Float64}, N::Int)\n\nReturns the gradient of the figure of merit with respect to the shot weights given the trace of the gate eigenvalue estimator covariance matrix sigma_tr and its square sigma_sq_tr, the gradient with respect to the shot weights sigma_tr_grad and the gradient of the square sigma_sq_tr_grad, and the number of gate eigenvalues N.\n\n\n\n\n\n","category":"method"},{"location":"internal/weights/#QuantumACES.get_shot_weights_factor-Tuple{Vector{Float64}, Vector{Float64}, Vector{Int64}}","page":"weights.jl","title":"QuantumACES.get_shot_weights_factor","text":"get_shot_weights_factor(shot_weights::Vector{Float64}, tuple_times::Vector{Float64}, mapping_lengths::Vector{Int})\n\nReturns the shot weights factor for the sparse block diagonal circuit (log-)eigenvalue estimator covariance matrix for the shot weights shot_weights and tuple times tuple_times, where the block sizes are specified by mapping_lengths.\n\n\n\n\n\n","category":"method"},{"location":"internal/weights/#QuantumACES.get_shot_weights_factor_inv-Tuple{Vector{Float64}, Vector{Float64}, Vector{Int64}}","page":"weights.jl","title":"QuantumACES.get_shot_weights_factor_inv","text":"get_shot_weights_factor_inv(shot_weights::Vector{Float64}, tuple_times::Vector{Float64}, mapping_lengths::Vector{Int})\n\nReturns the shot weights inverse factor for the sparse block diagonal circuit (log-)eigenvalue estimator covariance matrix for the shot weights shot_weights and tuple times tuple_times, where the block sizes are specified by mapping_lengths.\n\n\n\n\n\n","category":"method"},{"location":"internal/weights/#QuantumACES.get_shot_weights_local_grad-Tuple{Vector{Float64}, Vector{Float64}}","page":"weights.jl","title":"QuantumACES.get_shot_weights_local_grad","text":"get_shot_weights_local_grad(shot_weights::Vector{Float64}, tuple_times::Vector{Float64})\n\nReturns the local gradient factor corresponding to each tuple's block in the covariance matrix, at shot weights shot_weights and tuple times tuple_times.\n\n\n\n\n\n","category":"method"},{"location":"internal/weights/#QuantumACES.get_shot_weights_log_matrix-Tuple{Vector{Float64}}","page":"weights.jl","title":"QuantumACES.get_shot_weights_log_matrix","text":"get_shot_weights_log_matrix(shot_weights::Vector{Float64})\n\nReturns the matrix that transforms the gradient of the figure of merit with respect to the shot weights shot_weights into the gradient of the figure of merit with respect to the logarithms of the shot weights.\n\n\n\n\n\n","category":"method"},{"location":"internal/kwargs/","page":"kwargs.jl","title":"kwargs.jl","text":"CollapsedDocStrings = true","category":"page"},{"location":"internal/kwargs/#kwargs.jl","page":"kwargs.jl","title":"kwargs.jl","text":"","category":"section"},{"location":"internal/kwargs/#Public-functions","page":"kwargs.jl","title":"Public functions","text":"","category":"section"},{"location":"internal/kwargs/","page":"kwargs.jl","title":"kwargs.jl","text":"Modules = [QuantumACES]\nPages = [\"kwargs.jl\"]\nPrivate = false","category":"page"},{"location":"internal/kwargs/#QuantumACES.OptimOptions-internal-kwargs","page":"kwargs.jl","title":"QuantumACES.OptimOptions","text":"OptimOptions\n\nKeyword arguments for optimise_design, and specifically the optimisation functions within it, including for the gradient descent function optimise_weights, the repetition number optimisation function optimise_repetitions, and the tuple set optimisation function optimise_tuple_set.\n\nGeneral options\n\nls_type::Symbol = :wls: The type of least squares estimator for which we optimise the design, which can be :gls, :wls, or :ols.\nsave_data::Bool = false: Whether to automatically save the optimised design.\n\nGradient descent options\n\nlearning_rate::Float64 = (ls_type == :ols ? 1.0 : 10.0^(3/4)): Learning rate for the gradient descent algorithm.\nmomentum::Float64 = 0.99: Momentum for the gradient descent algorithm.\nlearning_rate_scale_factor::Float64 = 10.0^(1/4): Factor by which to reduce the learning rate if the gradient descent algorithm repeatedly steps in directions that reduce the figure of merit.\nshot_weights_clip::Float64 = 1e-5: If any tuple has shot weight below this threshold, the algorithm greedily considers pruning it from the tuple set.\nmax_steps::Int = 400: Maximum number of gradient descent steps to take.\nconvergence_threshold::Float64 = 1e-5: Convergence threshold for the gradient descent algorithm.\nconvergence_steps::Int = 5: Number of steps over which to check convergence.\ngrad_diagnostics::Bool = false: Whether to display gradient descent diagnostics.\n\nReptition number optimisation options\n\nmax_cycles::Int = 50: Maximum number of cycles to use in the cyclic coordinate descent algorithm for optimising repetition numbers.\nrep_diagnostics::Bool = true: Whether to display repetition number optimisation diagnostics.\n\nTuple set optimisation options\n\nexcursion_number::Int = 5: Number of excurisons used to optimise the tuple set.\nexcursion_length::Int = 5: Number of tuples added by each excursion past the max_tuple_number, so that at the end of an excursion the tuple set will have up to max_tuple_number + excursion_length tuples.\nmax_tuple_number::Int = 35: Maximum number of tuples in the optimised tuple set.\nmax_tuple_length::Int = 20: Maximum length of random tuples.\ntuple_length_zipf_power::Float64 = 1.0: Zipf power to use when Zipf-randomly choosing the length of random tuples.\nrepeat_zipf_powers::Vector{Float64} = [Inf; 2.0]: Zipf power to use, chosen uniformly at random from the vector, when Zipf-randomly choosing how many times to repeat entries that will be appended to the end of a random tuple during its generation.\nmirror_values::Vector{Bool} = [false; true]: Whether to mirror the tuple, chosen uniformly at random from the vector, when generating random tuples.\ntrial_factor::Int = 20: Number of random tuples trialled for each tuple the excursion needs to add to the tuple set to grow it to the max_tuple_number.\ngrow_greedy::Bool = true: Whether the excursions add tuples to the set greedily according to the figure of merit, or to add them even if this reduces the figure of merit.\nseed::Union{UInt64, Nothing} = nothing: Seed used to randomly generate tuples.\ntuple_diagnostics::Bool = true: Whether to display tuple set optimisation diagnostics.\n\n\n\n\n\n","category":"type"},{"location":"internal/kwargs/#Private-functions","page":"kwargs.jl","title":"Private functions","text":"","category":"section"},{"location":"internal/kwargs/","page":"kwargs.jl","title":"kwargs.jl","text":"Modules = [QuantumACES]\nPages = [\"kwargs.jl\"]\nPublic = false","category":"page"},{"location":"internal/simulate/","page":"simulate.jl","title":"simulate.jl","text":"CollapsedDocStrings = true","category":"page"},{"location":"internal/simulate/#simulate.jl","page":"simulate.jl","title":"simulate.jl","text":"","category":"section"},{"location":"internal/simulate/#Public-functions","page":"simulate.jl","title":"Public functions","text":"","category":"section"},{"location":"internal/simulate/","page":"simulate.jl","title":"simulate.jl","text":"Modules = [QuantumACES]\nPages = [\"simulate.jl\"]\nPrivate = false","category":"page"},{"location":"internal/simulate/#QuantumACES.ACESData-internal-simulate","page":"simulate.jl","title":"QuantumACES.ACESData","text":"ACESData\n\nACES noise characterisation experiment simulation results.\n\nFields\n\nd::Design: Experimental design.\nbudget_set::Vector{Int}: Measurement budgets.\nshots_set::Vector{Int}: Measurement shots corresponding to the measurement budgets in budget_set.\nrepetitions::Int: Number of times to repeat the ACES estimation procedure.\nseeds::Vector{UInt64}: Seeds for each of the repetitions.\neigenvalues::Vector{Float64}: Circuit eigenvalues.\ncovariance::SparseMatrixCSC{Float64, Int32}: Circuit eigenvalue estimator covariance matrix.\nest_eigenvalues_coll::Matrix{Vector{Float64}}: Estimated circuit eigenvalues for each of the measurement budgets and repetitions.\nfgls_gate_eigenvalues_coll::Matrix{Vector{Float64}}: FGLS estimated gate eigenvalues for each of the measurement budgets and repetitions.\ngls_gate_eigenvalues_coll::Matrix{Vector{Float64}}: GLS estimated gate eigenvalues for each of the measurement budgets and repetitions, which uses the true circuit eigenvalue estimator covariance matrix.\nwls_gate_eigenvalues_coll::Matrix{Vector{Float64}}: WLS estimated gate eigenvalues for each of the measurement budgets and repetitions.\nols_gate_eigenvalues_coll::Matrix{Vector{Float64}}: OLS estimated gate eigenvalues for each of the measurement budgets and repetitions.\nfgls_gate_probabilities_coll::Matrix{Dict{Gate, Vector{Float64}}}: FGLS estimated gate probability distributions for each of the measurement budgets and repetitions.\ngls_gate_probabilities_coll::Matrix{Dict{Gate, Vector{Float64}}}: GLS estimated gate probability distributions for each of the measurement budgets and repetitions.\nwls_gate_probabilities_coll::Matrix{Dict{Gate, Vector{Float64}}}: WLS estimated gate probability distributions for each of the measurement budgets and repetitions.\nols_gate_probabilities_coll::Matrix{Dict{Gate, Vector{Float64}}}: OLS estimated gate probability distributions for each of the measurement budgets and repetitions.\nfgls_gate_norm_coll::Matrix{Float64}: Normalised RMS error between the FGLS estimated gate eigenvalues and the true gate eigenvalues for each of the measurement budgets and repetitions.\ngls_gate_norm_coll::Matrix{Float64}: Normalised RMS error between the GLS estimated gate eigenvalues and the true gate eigenvalues for each of the measurement budgets and repetitions.\nwls_gate_norm_coll::Matrix{Float64}: Normalised RMS error between the WLS estimated gate eigenvalues and the true gate eigenvalues for each of the measurement budgets and repetitions.\nols_gate_norm_coll::Matrix{Float64}: Normalised RMS error between the OLS estimated gate eigenvalues and the true gate eigenvalues for each of the measurement budgets and repetitions.\ncalculation_times::Matrix{Float64}: Time taken to simulate sampling and estimate the gate eigenvalues with FGLS, GLS, WLS, and OLS for each repetition.\noverall_time::Float64: Overall time taken to simulate ACES across all repetitions.\n\n\n\n\n\n","category":"type"},{"location":"internal/simulate/#QuantumACES.simulate_aces-Tuple{Design, Vector{Int64}}-internal-simulate","page":"simulate.jl","title":"QuantumACES.simulate_aces","text":"simulate_aces(d::Design, budget_set::Vector{Int}; kwargs...)\n\nSimulates ACES noise characterisation experiments for the experimental design d across each of the measurement budgets in budget_set.\n\nWARNING: Seeding has the same features as in Stim. The behaviour of the same random seed will differ across different versions of Stim. Also, when measurement shots are sampled in batches, which occurs when max_samples is exceeded, the results will differ from when all shots are sampled at once.\n\nArguments\n\nd::Design: Experimental design.\nbudget_set::Vector{Int}: Measurement budgets for which to simulate ACES.\n\nKeyword arguments\n\nrepetitions::Int = 1: Number of simulation repetitions.\nseed::Union{UInt64, Nothing} = nothing: the seed to use for the random number generator.\nN_warn::Int = 3 * 10^4: Number of circuit eigenvalues above which to warn the user about certain keyword argument choices.\nmax_samples::Int = 10^10: Maximum number of Stim samples collected in a single simulation.\nforce_gc::Bool = false: Whether to force garbage collection before and after each Stim simulation; this was added to prevent occasional segfaults but massively slows down the simulation, and currently does not appear to be necessary.\ndiagnostics::Bool = true: Whether to print diagnostics.\ndetailed_diagnostics::Bool = false: Whether to print detailed diagnostics.\nsave_data::Bool = false: Whether to save the data.\nsave_interval::Int = 50: Repetition interval at which to save the data.\nclear_design::Bool = false: Whether to clear the saved design data after saving the full simulation data.\n\n\n\n\n\n","category":"method"},{"location":"internal/simulate/#Private-functions","page":"simulate.jl","title":"Private functions","text":"","category":"section"},{"location":"internal/simulate/","page":"simulate.jl","title":"simulate.jl","text":"Modules = [QuantumACES]\nPages = [\"simulate.jl\"]\nPublic = false","category":"page"},{"location":"internal/simulate/#QuantumACES.batch_shots-Tuple{Int64, Int64, Int64}","page":"simulate.jl","title":"QuantumACES.batch_shots","text":"batch_shots(shots::Int, measurements::Int, max_samples::Int)\n\nReturns the shots divided into batches for sampling from Stim.\n\n\n\n\n\n","category":"method"},{"location":"internal/simulate/#QuantumACES.estimate_eigenvalues-Tuple{Design, Vector{Int64}}","page":"simulate.jl","title":"QuantumACES.estimate_eigenvalues","text":"estimate_eigenvalues(d::Design, shots_set::Vector{Int}; kwargs...)\n\nReturns simulated estimated circuit eigenvalues for the experimental design d across each of the measurement shots counts specified in shots_set.\n\nKeyword arguments\n\nseed::Union{UInt64, Nothing} = nothing: Seed controlling the random seeds for Stim.\nepsilon::Float64 = 0.1: Set estimated circuit eigenvalues below this threshold to this value, which sometimes occurs for experiments with small shot weights when the measurement budget is small.\ndetailed_diagnostics::Bool = false: Whether to print diagnostic information about the simulation.\nmax_samples::Int = 10^10: Maximum number of samples to take in a single Stim simulation.\nforce_gc::Bool = false: Whether to force garbage collection before and after each Stim simulation.\n\n\n\n\n\n","category":"method"},{"location":"internal/simulate/#QuantumACES.estimate_gate_probabilities-Tuple{Design, Vector{Float64}}","page":"simulate.jl","title":"QuantumACES.estimate_gate_probabilities","text":"estimate_gate_probabilities(d::Design, est_gate_eigenvalues::Vector{Float64})\n\nReturns the gate Pauli error probabilities estimated from the estimated gate eigenvalues est_gate_eigenvalues corresponding to the design d. The estimated probability distributions are projected into the probability simplex.\n\n\n\n\n\n","category":"method"},{"location":"internal/simulate/#QuantumACES.fgls_estimate_gate_eigenvalues-Tuple{Design, Vector{Float64}}","page":"simulate.jl","title":"QuantumACES.fgls_estimate_gate_eigenvalues","text":"fgls_estimate_gate_eigenvalues(d::Design, est_eigenvalues::Vector{Float64}; kwargs...)\n\nReturns the gate eigenvalues estimated from the estimated circuit eigenvalues est_eigenvalues corresponding to the design d with feasible generalised least squares.\n\nKeyword arguments\n\nepsilon::Float64 = 1e-10: Threshold for convergence of the feasible generalised least squares algorithm.\nmax_iterations::Int = 10: Maximum number of iterations for the feasible generalised least squares algorithm.\nrecalc_eigenvalues::Bool = true: If true, the circuit eigenvalues are recalculated from the estimated gate eigenvalues at each iteration, which ensures that the estimated covariance matrix is positive-definite.\nconstrain::Bool = true: If true, the gate eigenvalues are constrained to be at most 1.\ndiagnostics::Bool = false: Whether to print diagnostic information about the feasible generalised least squares algorithm.\n\n\n\n\n\n","category":"method"},{"location":"internal/simulate/#QuantumACES.get_stim_circuit_string-Tuple{Vector{Layer}, Dict{Gate, Vector{Float64}}, Bool, Bool}","page":"simulate.jl","title":"QuantumACES.get_stim_circuit_string","text":"get_stim_circuit_string(circuit::Vector{Layer}, gate_probabilities::Dict{Gate, Vector{Float64}}, add_prep::Bool, add_meas::Bool)\n\nReturns a Stim string representation of the circuit circuit alongside error probabilities specified by gate_probabilities, as well as noisy preparations if add_prep is true, and noisy measurements if add_meas is true.\n\n\n\n\n\n","category":"method"},{"location":"internal/simulate/#QuantumACES.gls_estimate_gate_eigenvalues-Tuple{Design, Vector{Float64}, SparseArrays.SparseMatrixCSC{Float64, Int32}}","page":"simulate.jl","title":"QuantumACES.gls_estimate_gate_eigenvalues","text":"gls_estimate_gate_eigenvalues(d::Design, est_eigenvalues::Vector{Float64}, est_covariance::SparseMatrixCSC{Float64, Int32}; constrain::Bool = true)\n\nReturns the gate eigenvalues estimated from the estimated circuit eigenvalues est_eigenvalues corresponding to the design d with generalised least squares, with estimated circuit eigenvalue covariance matrix est_covariance. If constrain is true, the gate eigenvalues are constrained to be at most 1.\n\n\n\n\n\n","category":"method"},{"location":"internal/simulate/#QuantumACES.ols_estimate_gate_eigenvalues-Tuple{Design, Vector{Float64}}","page":"simulate.jl","title":"QuantumACES.ols_estimate_gate_eigenvalues","text":"ols_estimate_gate_eigenvalues(d::Design, est_eigenvalues::Vector{Float64}; constrain::Bool = true)\n\nReturns the gate eigenvalues estimated from the estimated circuit eigenvalues est_eigenvalues corresponding to the design d with ordinary least squares. If constrain is true, the gate eigenvalues are constrained to be at most 1.\n\n\n\n\n\n","category":"method"},{"location":"internal/simulate/#QuantumACES.stim_sample-Tuple{String, Int64}","page":"simulate.jl","title":"QuantumACES.stim_sample","text":"stim_sample(stim_circuit_string::String, shots::Int; stim_seed::Union{UInt64, Nothing} = nothing, force_gc::Bool = false)\n\nReturns bit-packaged measurement outcomes from simulating the circuit stim_circuit_string over shots measurement shots using the Python package Stim. While the seed stim_seed can be fixed, Stim guarantees inconsistency when using the same seed on different versions.\n\n\n\n\n\n","category":"method"},{"location":"internal/simulate/#QuantumACES.wls_estimate_gate_eigenvalues-Tuple{Design, Vector{Float64}}","page":"simulate.jl","title":"QuantumACES.wls_estimate_gate_eigenvalues","text":"wls_estimate_gate_eigenvalues(d::Design, est_eigenvalues::Vector{Float64}; constrain::Bool = true)\n\nReturns the gate eigenvalues estimated from the estimated circuit eigenvalues est_eigenvalues corresponding to the design d with weighted least squares. If constrain is true, the gate eigenvalues are constrained to be at most 1.\n\n\n\n\n\n","category":"method"},{"location":"internal/scaling/","page":"scaling.jl","title":"scaling.jl","text":"CollapsedDocStrings = true","category":"page"},{"location":"internal/scaling/#scaling.jl","page":"scaling.jl","title":"scaling.jl","text":"","category":"section"},{"location":"internal/scaling/#Public-functions","page":"scaling.jl","title":"Public functions","text":"","category":"section"},{"location":"internal/scaling/","page":"scaling.jl","title":"scaling.jl","text":"Modules = [QuantumACES]\nPages = [\"scaling.jl\"]\nPrivate = false","category":"page"},{"location":"internal/scaling/#QuantumACES.DepolarisingPlanarScaling-internal-scaling","page":"scaling.jl","title":"QuantumACES.DepolarisingPlanarScaling","text":"DepolarisingPlanarScaling\n\nScaling data for an experimental design for the syndrome extraction circuit of a surface code with depolarising Pauli noise.\n\nFields\n\ndist_range::Vector{Int}: Code distances.\nmerit_scaling::Vector{Merit}: Merit of the design for a range of code distances.\nG_fit::Function: Gate number fit.\nG_params::Vector{Int}: Gate number fit parameters; a + bd + cd^2.\nN_fit::Function: Gate eigenvalue number fit.\nN_params::Vector{Int}: Gate eigenvalue number fit parameters; a + bd + cd^2.\ntrace_fit::Function: Trace of the gate eigenvalue estimator covariance matrix fit.\ntrace_params::Vector{Float64}: Trace of the gate eigenvalue estimator covariance matrix fit parameters; a + bd + cd^2.\ntrace_sq_fit::Function: Trace of the gate eigenvalue estimator covariance matrix squared fit.\ntrace_sq_params::Vector{Float64}: Trace of the gate eigenvalue estimator covariance matrix squared fit parameters; a + bd + cd^2.\nexpectation_fit::Function: Normalised RMS error expectation fit.\nvariance_fit::Function: Normalised RMS error variance fit.\ncircuit_param::AbstractCircuitParameters: Code parameters.\nnoise_param::DepolarisingParameters: Depolarising noise parameters.\ntuple_set::Vector{Vector{Int}}: Set of tuples which arrange the circuit layers.\ntuple_set_data::TupleSetData: TupleSetData object that generates the tuple set.\nshot_weights::Vector{Float64}: Shot weights for each tuple in the set, which add to 1.\nls_type::Symbol: Type of least squares estimator for which the merits were calculated.\ncalculation_times::Matrix{Float64}: Time taken to generate the design and calculate the merit, respectively, for each distance.\noverall_time::Float64: The overall time taken to calculate the merit scaling data for depolarising noise.\n\n\n\n\n\n","category":"type"},{"location":"internal/scaling/#QuantumACES.LognormalPlanarScaling-internal-scaling","page":"scaling.jl","title":"QuantumACES.LognormalPlanarScaling","text":"LognormalPlanarScaling\n\nScaling data for an experimental design for the syndrome extraction circuit of a surface code with log-normal random Pauli noise.\n\nFields\n\ndist_range::Vector{Int}: Code distances.\nN_fit::Function: Gate eigenvalue number fit.\nN_params::Vector{Int}: Gate eigenvalue number fit parameters; a + bd + cd^2.\nexpectation_scaling::Vector{Vector{Float64}}: Expected normalised RMS error for a range of code distances.\nexpectation_fit::Function: Mean expected normalised RMS error fit.\nvariance_scaling::Vector{Vector{Float64}}: Normalised RMS error variance for a range of code distances.\nvariance_fit::Function: Mean normalised RMS error variance fit.\neigenvalues_scaling::Vector{Vector{Vector{Float64}}}: Eigenvalues of the gate log-eigenvalue estimator covariance matrix for a range of code distances.\ncircuit_param::AbstractCircuitParameters: Code parameters.\nnoise_param::LognormalParameters: Log-normal random noise parameters.\nseeds::Vector{UInt64}: Seeds for the log-normal noise parameters.\ntuple_set::Vector{Vector{Int}}: Set of tuples which arrange the circuit layers.\ntuple_set_data::TupleSetData: TupleSetData object that generates the tuple set.\nshot_weights::Vector{Float64}: Shot weights for each tuple in the set, which add to 1.\nls_type::Symbol: Type of least squares estimator for which the merits were calculated.\ncalculation_times::Matrix{Float64}: The time taken to generate the design and calculate the figures of merit for random instances of log-normal Pauli noise, and for depolarising Pauli noise, respectively.\noverall_time::Float64: The overall time taken to calculate the merit scaling for log-normal random noise.\n\n\n\n\n\n","category":"type"},{"location":"internal/scaling/#QuantumACES.calc_depolarising_planar_scaling-Tuple{Design, Vector{Int64}}-internal-scaling","page":"scaling.jl","title":"QuantumACES.calc_depolarising_planar_scaling","text":"calc_depolarising_planar_scaling(d::Design, dist_max::Int; kwargs...)\ncalc_depolarising_planar_scaling(d::Design, dist_range::Vector{Int}; kwargs...)\n\nReturns the scaling data as a DepolarisingPlanarScaling object for the figure of merit of the design d for the syndrome extraction circuit of a surface code with depolarising Pauli noise, as a function of the distance of the code.\n\nArguments\n\nd::Design: Design for which the merit scaling is calculated.\ndist_max::Int: Maximum code distance for which the merit scaling is calculated.\ndist_range::Vector{Int}: Vode distances for which the merit scaling is calculated.\n\nKeyword arguments\n\nls_type::Symbol = :none: Type of least squares estimator used to calculate the merit scaling, which defaults to the least squares estimator type of the design, or if that is not specified, :wls.\ndiagnostics::Bool = true: Whether to print diagnostic information.\nsave_data::Bool = false: Whether to save the merit scaling data.\n\n\n\n\n\n","category":"method"},{"location":"internal/scaling/#QuantumACES.calc_lognormal_planar_scaling-Tuple{Design, Vector{Int64}}-internal-scaling","page":"scaling.jl","title":"QuantumACES.calc_lognormal_planar_scaling","text":"calc_lognormal_planar_scaling(d::Design, dist_max::Int; kwargs...)\ncalc_lognormal_planar_scaling(d::Design, dist_range::Vector{Int}; kwargs...)\n\nReturns the scaling data as a LognormalPlanarScaling object for the figure of merit of the design d for the syndrome extraction circuit of a surface code with log-normal random Pauli noise, as a function of the distance of the code.\n\nArguments\n\nd::Design: Design for which the merit scaling is calculated.\ndist_max::Int: Maximum code distance for which the merit scaling is calculated.\ndist_range::Vector{Int}: Code distances for which the merit scaling is calculated.\n\nKeyword arguments\n\nls_type::Symbol = :none: Type of least squares estimator used to calculate the merit scaling, which defaults to the least squares estimator type of the design, or if that is not specified, :wls.\nprecision::Float64 = 1e-3: Precision to which the figure of merit is estimated, corresponding to the target standard error of the mean.\nmax_repetitions::Int = 10000: Maximum number of random instances of log-normal Pauli noise over which the figure of merit is calculated.\nmin_repetitions::Int = 100: Minimum number of random instances of log-normal Pauli noise over which the figure of merit is calculated.\nprint_repetitions::Int = 100: Number of random instances of log-normal Pauli noise between printing diagnostics.\nseed::Union{UInt64, Nothing} = nothing: Seeds used to generate instances of log-normal Pauli noise.\ndiagnostics::Bool = true: Whether to print diagnostic information.\nsave_data::Bool = false: Whether to save the merit scaling data.\n\n\n\n\n\n","category":"method"},{"location":"internal/scaling/#Private-functions","page":"scaling.jl","title":"Private functions","text":"","category":"section"},{"location":"internal/scaling/","page":"scaling.jl","title":"scaling.jl","text":"Modules = [QuantumACES]\nPages = [\"scaling.jl\"]\nPublic = false","category":"page"},{"location":"manual/#Package-Guide","page":"Manual","title":"Package Guide","text":"","category":"section"},{"location":"manual/#Introduction","page":"Manual","title":"Introduction","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"QuantumACES.jl is a package for designing and simulating scalable and performant Pauli noise characterisation experiments for stabiliser circuits with averaged circuit eigenvalue sampling (ACES). It is particularly interested in characterising the noise associated with fault-tolerant gadgets in the context of topological quantum error correcting codes, such as surface code syndrome extraction circuits.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"The methods used in this package are detailed in arXiv:2404.06545, and the code generating the data for this paper can be found in the scalable_aces folder on the scalable_aces branch. These methods build on the original ACES protocol presented in arXiv:2108.05803. This package relies on Stim for stabiliser circuit simulations.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"Typical usage of this package involves a few steps:","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"Constructing the circuit and noise model for which you aim to perform an ACES noise characterisation experiment, using either provided functions or your own.\nOptimise an experimental design for a depolarising noise model with the same average error rates as the noise model you aim to characterise.\nOptional: Predict the performance of the experimental design, including its scaling as a function of circuit parameters, for example as a function of the code distance in the case of surface code syndrome extraction circuits.\nSimulate noise characterisation experiments across a range of specified measurement budgets that use the optimised experimental design. ","category":"page"},{"location":"manual/#Installation-and-setup","page":"Manual","title":"Installation and setup","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"This is not currently a registered package, so to add it you can run","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"julia> # press ] to enter the Pkg REPL\n\npkg> add https://github.com/evanhockings/QuantumACES.jl","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"This package relies on the Python package Stim to perform stabiliser simulations. It calls stim with PythonCall, which can be a little tricky to set up. One helpful method for managing Python versions is pyenv, or for Windows, pyenv-win, which is analogous to Juliaup for Julia.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"On Windows, to instruct PythonCall to use the Python version set by pyenv, configure PythonCall's environment variables by adding the following to your ~/.julia/config/startup.jl file","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"ENV[\"JULIA_CONDAPKG_BACKEND\"] = \"Null\"\npython_exe = readchomp(`cmd /C pyenv which python`)\nENV[\"JULIA_PYTHONCALL_EXE\"] = python_exe","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"On Unix systems, shell commands are parsed directly by Julia and appear to be unaware of your PATH variable. I am not sure how to fix this, so you may need to manually supply python_exe for the Python version <version> as","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"python_exe = homedir() * \"/.pyenv/versions/<version>/bin/python\"","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"Then ensure Stim is installed by running pip install stim in your terminal.","category":"page"},{"location":"manual/#Example-usage","page":"Manual","title":"Example usage","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"To see a full example showing how this package can be used, see the code that generates the data for arXiv:2404.06545 in the scalable_aces folder on the scalable_aces branch.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"Beware that the examples shown below may take a number of hours to run. Ensure that Julia is set up to use as many threads as your CPU can handle.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"First parameterise a depolarising noise model with single-qubit gate infidelity r_1, two-qubit gate infidelity r_2, and measurement infidelity r_m, and a log-normal random Pauli noise model with the same gate infidelities and a standard deviation of the underlying normal distributions total_std_log, alongside a random seed used when generating the noise model.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"r_1 = 0.075 / 100\nr_2 = 0.5 / 100\nr_m = 2.0 / 100\ntotal_std_log = sqrt(log(10 / 9))\nseed = UInt(0)\ndep_param = get_dep_param(r_1, r_2, r_m)\nlog_param = get_log_param(r_1, r_2, r_m, total_std_log; seed = seed)","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"Then generate the syndrome extraction circuit for a distance dist (rotated) surface code.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"dist = 3\nrotated_param = get_rotated_param(dist)\nrotated_planar = get_circuit(rotated_param, dep_param)","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"Optimise an experimental design for these parameters, configuring the optimisation with the parameters associated with OptimOptions.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"d = optimise_design(rotated_planar, options = OptimOptions(; ls_type = :wls, seed = seed))","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"Create a copy of the optimised design that associates log-normal random Pauli noise with the circuit, and simulate repetitions rounds of an ACES noise characterisation experiment across all of the supplied measurement budgets in budget_set, which are measurement shots normalised by the time taken to perform the experiment.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"d_log = update_noise(d, log_param)\nbudget_set = [10^6; 10^7; 10^8]\nrepetitions = 20\naces_data = simulate_aces(d_log, budget_set; repetitions = repetitions)","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"We can compare the performance to performance predictions at the largest measurement budget, although we note that the z-scores will not be normally distributed as the underlying distribution is not quite normal.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"wls_merit_log = calc_wls_merit(d_log)\nfgls_z_scores =\n    (aces_data.fgls_gate_norm_coll[:, 3] .- wls_merit_log.expectation) /\n    sqrt(wls_merit_log.variance)","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"Next, calculate the performance scaling of this design as a fuction of the code distance up to some large distance dist_max with the weighted least squares (WLS) estimator, for both depolarising and log-normal random Pauli noise.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"dist_max = 9\ndep_planar_scaling = calc_depolarising_planar_scaling(d, dist_max; ls_type = :wls)\nlog_planar_scaling = calc_lognormal_planar_scaling(d_log, dist_max; ls_type = :wls, seed = seed)","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"Next, transfer the optimised experimental design to the syndrome extraction circuit for a distance dist_big surface code with log-normal random Pauli noise.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"dist_big = 13\nrotated_param_big = get_rotated_param(dist_big)\nrotated_planar_big = get_circuit(rotated_param_big, log_param)\nd_big = generate_design(rotated_planar_big, d.tuple_set_data)","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"We can simulate a large-scale ACES noise characterisation experiment across the supplied measurement budgets.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"budget_set_big = [10^6; 10^7; 10^8; 10^9]\naces_data_big = simulate_aces(d_big, budget_set_big)","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"Finally, we compare the performance to predictions across the measurement budgets, although note that we would not expect the z-scores here to actually correspond to a normal distribution as the underlying distribution is not quite normal, and there is a substantive amount of uncertainty associated with the fit.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"pred_expectation = log_planar_scaling.expectation_fit(dist_big)\npred_variance = log_planar_scaling.variance_fit(dist_big)\nfgls_z_scores_big =\n    (aces_data_big.fgls_gate_norm_coll[1, :] .- pred_expectation) / sqrt(pred_variance)","category":"page"},{"location":"manual/#More-advanced-usage","page":"Manual","title":"More advanced usage","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"This package also supports creating your own circuits and noise models.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"Let us begin by creating a new circuit, following the example circuit shown in Figure 2 of arXiv:2404.06545. The first step is to create a parameter struct for the circuit, which must be a subtype of AbstractCircuitParameters and contain the necessary fields layer_time_dict and circuit_name.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"struct ExampleParameters <: AbstractCircuitParameters\n    pad_identity::Bool\n    layer_time_dict::Dict{Symbol, Float64}\n    circuit_name::String\nend","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"We need a function to construct the parameter struct.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"function get_example_parameters(;\n    pad_identity = true,\n    single_qubit_time::Float64 = 29.0,\n    two_qubit_time::Float64 = 29.0,\n    meas_reset_time::Float64 = 660.0,\n)\n    # Create the example parameters\n    @assert single_qubit_time > 0.0 \"The single-qubit layer time must be positive.\"\n    @assert two_qubit_time > 0.0 \"The two-qubit layer time must be positive.\"\n    @assert meas_reset_time > 0.0 \"The measurement and reset layer time must be positive.\"\n    layer_time_dict = Dict(\n        :single_qubit => single_qubit_time,\n        :two_qubit => two_qubit_time,\n        :meas_reset => meas_reset_time,\n    )\n    circuit_name = \"example_circuit\"\n    if pad_identity != true\n        circuit_name *= \"_pad_identity_$(pad_identity)\"\n    end\n    example_param = ExampleParameters(pad_identity, layer_time_dict, \"example_circuit\")\n    return example_param::ExampleParameters\nend","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"And we need a function to create the circuit from the parameter struct.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"function example_circuit(example_param::ExampleParameters)\n    # Set up variables\n    pad_identity = example_param.pad_identity\n    layer_time_dict = example_param.layer_time_dict\n    single_qubit_type = :single_qubit\n    two_qubit_type = :two_qubit\n    # Generate the circuit\n    qubit_num = 3\n    circuit = [\n        Layer([Gate(\"CZ\", 0, [2; 3])], qubit_num),\n        Layer([Gate(\"CX\", 0, [1; 2]), Gate(\"H\", 0, [3])], qubit_num),\n        Layer([Gate(\"H\", 0, [1]), Gate(\"S\", 0, [2]), Gate(\"H\", 0, [3])], qubit_num),\n    ]\n    layer_types = [two_qubit_type, two_qubit_type, single_qubit_type]\n    layer_times = get_layer_times(layer_types, layer_time_dict)\n    # Pad each layer with identity gates if appropriate\n    if pad_identity\n        circuit = [pad_layer(l) for l in circuit]\n    end\n    return (\n        circuit::Vector{Layer},\n        qubit_num::Int,\n        layer_types::Vector{Symbol},\n        layer_times::Vector{Float64},\n    )\nend","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"Finally, we create a function that generates the circuit in the form of a Circuit struct. We do this by adding a method to get_circuit which uses the new parameter struct as an argument. A helpful function for this is prepare_circuit, which deals with much of the busywork associated with generating the circuit.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"function QuantumACES.get_circuit(\n    example_param::ExampleParameters,\n    noise_param::T;\n    add_prep::Bool = false,\n    add_meas::Bool = true,\n) where {T <: AbstractNoiseParameters}\n    # Construct the circuit\n    (circuit, qubit_num, layer_types, layer_times) = example_circuit(example_param)\n    circuit_tuple = collect(1:length(circuit))\n    # Prepare the circuit and generate additional parameters\n    (\n        labelled_circuit,\n        unique_layer_indices,\n        gates,\n        total_gates,\n        gate_index,\n        N,\n        gate_probabilities,\n        gate_eigenvalues,\n    ) = prepare_circuit(\n        circuit,\n        qubit_num,\n        layer_types,\n        layer_times,\n        noise_param;\n        add_prep = add_prep,\n        add_meas = add_meas,\n    )\n    # Return the circuit\n    c = Circuit(\n        example_param,\n        labelled_circuit,\n        circuit_tuple,\n        qubit_num,\n        unique_layer_indices,\n        layer_types,\n        layer_times,\n        gates,\n        total_gates,\n        gate_index,\n        N,\n        noise_param,\n        gate_probabilities,\n        gate_eigenvalues,\n        add_prep,\n        add_meas,\n    )\n    return c::Circuit\nend","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"Make sure to follow the form of this example function when creating your own circuit. If you want to include more data with your circuit, create a new struct that is a subtype of AbstractCircuit, and add the necessary fields, namely all of those present in Circuit.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"Next, we will create a phenomenological noise model where each Pauli error probability has some probability p of occurring, so that two-qubit errors have a probability p^2. As with the circuit, we begin by creating a parameter struct for the noise model, which must be a subtype of AbstractNoiseParameters and contain the necessary field noise_name.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"struct PhenomenologicalParameters <: AbstractNoiseParameters\n    p::Float64\n    m::Float64\n    noise_name::String\nend","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"We need a function to construct the parameter struct.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"function get_phen_param(p::Float64, m::Float64)\n    @assert (p >= 0) && (p <= 1 / 10) \"The phenomenological gate error probability $(p) is out of bounds.\"\n    @assert (m >= 0) && (m <= 1 / 2) \"The phenomenological measurement error probability $(m) is out of bounds.\"\n    noise_name = \"phenomenological_$(round(p; sigdigits = 4))_$(round(m; sigdigits = 4))\"\n    return PhenomenologicalParameters(p, m, noise_name)::PhenomenologicalParameters\nend","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"And we need a function to create the noise model for a set of gates from the parameter struct. As with the circuit, we add a method to get_gate_probabilities which uses the new parameter struct as an argument.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"function QuantumACES.get_gate_probabilities(\n    total_gates::Vector{Gate},\n    noise_param::PhenomenologicalParameters,\n)\n    # Extract the parameters for generating the noise\n    p = noise_param.p\n    m = noise_param.m\n    # Determine the weight of the error corresponding to each gate error probability\n    one_qubit_support_size = ones(3)\n    n = 2\n    two_qubit_support_size = Vector{Int}(undef, 0)\n    bit_array = BitArray(undef, 2n + 1)\n    for bit_array.chunks[1] in 1:(2^(2n) - 1)\n        two_qubit_pauli = Pauli(convert(Vector{Bool}, bit_array), n)\n        push!(two_qubit_support_size, length(get_support(two_qubit_pauli)))\n    end\n    @assert sum(two_qubit_support_size .== 1) == 6\n    @assert sum(two_qubit_support_size .== 2) == 9\n    # Generate the noise\n    gate_probabilities = Dict{Gate, Vector{Float64}}()\n    for gate in total_gates\n        if gate.type ∈ [\"MZ\", \"MX\", \"MY\"]\n            probability = [m]\n        elseif length(gate.targets) == 1\n            probability = p .^ one_qubit_support_size\n        elseif length(gate.targets) == 2\n            probability = p .^ two_qubit_support_size\n        else\n            throw(error(\"The gate $(gate) is unsupported.\"))\n        end\n        @assert sum(probability) < 1 \"The probabilities $(probability) sum to more than 1; change the input parameters.\"\n        gate_probabilities[gate] = [1 - sum(probability); probability]\n    end\n    return gate_probabilities::Dict{Gate, Vector{Float64}}\nend","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"Make sure to follow the form of this example function when creating your own noise model.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"Now we are ready to reprise the basic usage example for this example circuit. First, parameterise depolarising and phenomenological noise models, making sure to create a depolarising noise model with the same gate infidelity as the phenomenological noise model.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"p = 0.025 / 100\nm = 2.0 / 100\nr_1 = 3 * p\nr_2 = 6 * p + 9 * p^2\nr_m = m\nphen_param = get_phen_param(p, m)\ndep_param = get_dep_param(r_1, r_2, r_m)","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"Then construct the circuit","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"example_param = get_example_parameters()\ncircuit_example = get_circuit(example_param, dep_param)","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"Optimise the experimental design for the generalised least squares (GLS) estimator as we are not interested in scaling this experimental design to large numbers of qubits, configuring the optimisation with the parameters associated with OptimOptions. This is because the circuit acts on only three qubits and, unlike the surface code syndrome extraction circuits, does not form a family of circuits.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"seed = UInt(0)\nd = optimise_design(circuit_example; options = OptimOptions(; ls_type = :gls, seed = seed))","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"Create a copy of the optimised design that associates phenomenological noise with the circuit, and compare the predicted performance of the experimental design with depolarising and phenomenological noise.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"d_phen = update_noise(d, phen_param)\nmerit_dep = calc_gls_merit(d)\nmerit_phen = calc_gls_merit(d_phen)","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"We can also simulate the performance of the experimental design with phenomenological noise.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"budget_set = [10^6; 10^7; 10^8]\nrepetitions = 20\naces_data = simulate_aces(d_phen, budget_set; repetitions = repetitions, seed = seed)","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"Finally, compare the performance to predictions at the largest measurement budget.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"fgls_z_scores_phen =\n    (aces_data.fgls_gate_norm_coll[:, 3] .- merit_phen.expectation) /\n    sqrt(merit_phen.variance)","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"As before, note that the distribution of the normalised RMS error between the estimated and true gate eigenvalues is not quite normally distributed. Hence the z-scores shown here, which are normalised by the predicted performance of the experimental design, will not quite be normally distributed.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"For a fuller understanding of the methods used in this package, refer to arXiv:2404.06545.","category":"page"},{"location":"internal/io/","page":"io.jl","title":"io.jl","text":"CollapsedDocStrings = true","category":"page"},{"location":"internal/io/#io.jl","page":"io.jl","title":"io.jl","text":"","category":"section"},{"location":"internal/io/#Public-functions","page":"io.jl","title":"Public functions","text":"","category":"section"},{"location":"internal/io/","page":"io.jl","title":"io.jl","text":"Modules = [QuantumACES]\nPages = [\"io.jl\"]\nPrivate = false","category":"page"},{"location":"internal/io/#QuantumACES.aces_data_filename-Union{Tuple{U}, Tuple{T}, Tuple{T, U, Int64, Vector{Int64}, Bool, Symbol, Vector{Int64}}} where {T<:AbstractCircuitParameters, U<:AbstractNoiseParameters}-internal-io","page":"io.jl","title":"QuantumACES.aces_data_filename","text":"aces_data_filename(aces_data::ACESData)\naces_data_filename(d::Design, budget_set::Vector{Int})\naces_data_filename(circuit_param::AbstractCircuitParameters, noise_param::AbstractNoiseParameters, tuple_number::Int, repeat_numbers::Vector{Int}, full_covariance::Bool, ls_type::Symbol, budget_set::Vector{Int})\n\nReturns a string describing the filename corresponding to the ACES data.\n\n\n\n\n\n","category":"method"},{"location":"internal/io/#QuantumACES.delete_aces-Tuple{ACESData}-internal-io","page":"io.jl","title":"QuantumACES.delete_aces","text":"delete_aces(aces_data::ACESData)\n\nDeletes the file corresponding to the ACES data aces_data.\n\n\n\n\n\n","category":"method"},{"location":"internal/io/#QuantumACES.delete_design-Tuple{Design}-internal-io","page":"io.jl","title":"QuantumACES.delete_design","text":"delete_design(d::Design)\n\nDeletes the file corresponding to the design d.\n\n\n\n\n\n","category":"method"},{"location":"internal/io/#QuantumACES.delete_scaling-Tuple{T} where T<:AbstractScalingData-internal-io","page":"io.jl","title":"QuantumACES.delete_scaling","text":"delete_scaling(scaling_data::AbstractScalingData)\n\nDeletes the file corresponding to the scaling data scaling_data.\n\n\n\n\n\n","category":"method"},{"location":"internal/io/#QuantumACES.design_filename-Union{Tuple{U}, Tuple{T}, Tuple{T, U, Int64, Vector{Int64}, Bool, Symbol}} where {T<:AbstractCircuitParameters, U<:AbstractNoiseParameters}-internal-io","page":"io.jl","title":"QuantumACES.design_filename","text":"design_filename(d::Design)\ndesign_filename(circuit_param::AbstractCircuitParameters, noise_param::AbstractNoiseParameters, tuple_number::Int, repeat_numbers::Vector{Int}, full_covariance::Bool, ls_type::Symbol)\n\nReturns a string describing the filename corresponding to the supplied design data.\n\n\n\n\n\n","category":"method"},{"location":"internal/io/#QuantumACES.enter_folder-Tuple{String}-internal-io","page":"io.jl","title":"QuantumACES.enter_folder","text":"enter_folder(folder::String)\n\nIf not currently in the folder folder, enter it.\n\n\n\n\n\n","category":"method"},{"location":"internal/io/#QuantumACES.exit_folder-Tuple{String}-internal-io","page":"io.jl","title":"QuantumACES.exit_folder","text":"exit_folder(folder::String)\n\nIf currently in the folder folder, exit it.\n\n\n\n\n\n","category":"method"},{"location":"internal/io/#QuantumACES.load_aces-Union{Tuple{U}, Tuple{T}, Tuple{T, U, Int64, Vector{Int64}, Bool, Symbol, Vector{Int64}}} where {T<:AbstractCircuitParameters, U<:AbstractNoiseParameters}-internal-io","page":"io.jl","title":"QuantumACES.load_aces","text":"load_aces(d::Design, budget_set::Vector{Int})\nload_aces(circuit_param::AbstractCircuitParameters, noise_param::AbstractNoiseParameters, tuple_number::Int, repeat_numbers::Vector{Int}, full_covariance::Bool, ls_type::Symbol, budget_set::Vector{Int})\n\nLoads the ACES data whose filename is specified by the supplied variables.\n\n\n\n\n\n","category":"method"},{"location":"internal/io/#QuantumACES.load_design-Union{Tuple{U}, Tuple{T}, Tuple{T, U, Int64, Vector{Int64}, Bool, Symbol}} where {T<:AbstractCircuitParameters, U<:AbstractNoiseParameters}-internal-io","page":"io.jl","title":"QuantumACES.load_design","text":"load_design(circuit_param::AbstractCircuitParameters, noise_param::AbstractNoiseParameters, tuple_number::Int, repeat_numbers::Vector{Int}, full_covariance::Bool, ls_type::Symbol)\n\nLoads the design whose filename is specified by the supplied variables.\n\n\n\n\n\n","category":"method"},{"location":"internal/io/#QuantumACES.load_scaling-Union{Tuple{U}, Tuple{T}, Tuple{T, U, Int64, Vector{Int64}, Symbol}} where {T<:AbstractCircuitParameters, U<:AbstractNoiseParameters}-internal-io","page":"io.jl","title":"QuantumACES.load_scaling","text":"load_scaling(d::Design, ls_type::Symbol)\nload_scaling(circuit_param::AbstractCircuitParameters, noise_param::AbstractNoiseParameters, tuple_number::Int, repeat_numbers::Vector{Int}, ls_type::Symbol)\n\nLoads the scaling data whose filename is specified by the supplied variables.\n\n\n\n\n\n","category":"method"},{"location":"internal/io/#QuantumACES.save_aces-Tuple{ACESData}-internal-io","page":"io.jl","title":"QuantumACES.save_aces","text":"save_aces(aces_data::ACESData; clear_design::Bool = false)\n\nSaves the ACES data aces_data with the appropriate filename, and deletes the design file if it exists and clear_design is true.\n\n\n\n\n\n","category":"method"},{"location":"internal/io/#QuantumACES.save_design-Tuple{Design}-internal-io","page":"io.jl","title":"QuantumACES.save_design","text":"save_design(d::Design)\n\nSaves the design d with the appropriate filename.\n\n\n\n\n\n","category":"method"},{"location":"internal/io/#QuantumACES.save_scaling-Tuple{T} where T<:AbstractScalingData-internal-io","page":"io.jl","title":"QuantumACES.save_scaling","text":"save_scaling(scaling_data::AbstractScalingData)\n\nSaves the scaling data scaling_data with the appropriate filename.\n\n\n\n\n\n","category":"method"},{"location":"internal/io/#QuantumACES.scaling_filename-Union{Tuple{U}, Tuple{T}, Tuple{T, U, Int64, Vector{Int64}, Symbol}} where {T<:AbstractCircuitParameters, U<:AbstractNoiseParameters}-internal-io","page":"io.jl","title":"QuantumACES.scaling_filename","text":"scaling_filename(scaling_data::AbstractScalingData)\nscaling_filename(d::Design, ls_type::Symbol)\nscaling_filename(circuit_param::AbstractCircuitParameters, noise_param::AbstractNoiseParameters, tuple_number::Int, repeat_numbers::Vector{Int}, ls_type::Symbol)\n\nReturns a string describing the filename for the scaling data corresponding to the supplied design data.\n\n\n\n\n\n","category":"method"},{"location":"internal/io/#Private-functions","page":"io.jl","title":"Private functions","text":"","category":"section"},{"location":"internal/io/","page":"io.jl","title":"io.jl","text":"Modules = [QuantumACES]\nPages = [\"io.jl\"]\nPublic = false","category":"page"},{"location":"internal/io/#QuantumACES.tuples_filename-Tuple{Int64, Vector{Int64}}","page":"io.jl","title":"QuantumACES.tuples_filename","text":"tuples_filename(tuple_number::Int, repeat_numbers::Vector{Int})\n\nReturns a string describing the filename for the supplied tuple set data.\n\n\n\n\n\n","category":"method"},{"location":"internal/design/","page":"design.jl","title":"design.jl","text":"CollapsedDocStrings = true","category":"page"},{"location":"internal/design/#design.jl","page":"design.jl","title":"design.jl","text":"","category":"section"},{"location":"internal/design/#Public-functions","page":"design.jl","title":"Public functions","text":"","category":"section"},{"location":"internal/design/","page":"design.jl","title":"design.jl","text":"Modules = [QuantumACES]\nPages = [\"design.jl\"]\nPrivate = false","category":"page"},{"location":"internal/design/#QuantumACES.Design-internal-design","page":"design.jl","title":"QuantumACES.Design","text":"Design\n\nExperimental design for a noise characterisation experiment for a circuit.\n\nFields\n\nc::AbstractCircuit: Circuit characterised by the design.\nfull_covariance::Bool: If true, generates parameters to construct the full covariance matrix in covariance_dict_ensemble, else if false, only generates parameters to construct the terms on the diagonal.\nmatrix::SparseMatrixCSC{Int32, Int32}: Sparse M x N design matrix, corresponding to M circuit eigenvalues and N gate eigenvalues.\ntuple_set::Vector{Vector{Int}}: Set of tuples which arrange the circuit layers.\ntuple_set_data::TupleSetData: TupleSetData object that generates the tuple set.\nmapping_ensemble::Vector{Vector{Mapping}}: Vector of the Mapping objects for each of the circuit eigenvalue for the Paulis corresponding to that tuple, for each tuple in the set.\nexperiment_ensemble::Vector{Vector{Vector{Int}}}: Vector of the experiments that index Mapping objects, which correspond to simultaneously preparable and measurable circuit eigenvalues, for each tuple in the set.\ncovariance_dict_ensemble::Vector{Dict{CartesianIndex{2}, Tuple{Mapping, Int}}}: Dictionary of Mapping objects describing the non-zero entries of the sparse circuit eigenvalue estimator covariance matrix, alongside the number of times the entry is estimated by the experiment set, for each tuple in the set.\nprep_ensemble::Vector{Vector{Vector{Layer}}}: Vector of Layer objects that prepare qubits in Pauli eigenstates for each experiment in the set, indeed a vector preparing the necessary sign configurations, for each tuple in the set.\nmeas_ensemble::Vector{Vector{Layer}}: Vector of Layer objects that measure qubits in Pauli bases for each experiment in the set, for each tuple in the set.\ntuple_times::Vector{Float64}: Time taken to implement the circuit arranged by each tuple in the set, normalised according to the time factor for the basic tuple set.\nshot_weights::Vector{Float64}: Shot weights for each tuple in the set, which add to 1.\nexperiment_numbers::Vector{Int}: Number of experiments for each tuple in the set.\nexperiment_number::Int: Total number of experiments.\ncalculation_times::Matrix{Float64}: Time taken to generate components of the design for each tuple, which correspond to generating: the mappings, the sets of tuple-consistent Pauli preparations, the experiment sets, the covariance matrix dictionary, and the circuits.\noverall_time::Float64: Overall time taken to generate the design.\noptimisation_time::Float64: Time taken to optimise the design.\nls_type::Symbol: Type of least squares for which the shot weights were optimised.\n\n\n\n\n\n","category":"type"},{"location":"internal/design/#QuantumACES.Mapping-internal-design","page":"design.jl","title":"QuantumACES.Mapping","text":"Mapping\n\nMapping of a Pauli operator by some circuit.\n\nFields\n\ninitial::Pauli: Initial Pauli operator before the action of the circuit.\nfinal::Pauli: Final Pauli operator after the action of the circuit.\ndesign_row::SparseVector{Int32, Int32}: Design matrix row for the circuit eigenvalue corresponding to the initial Pauli and the circuit used for the mapping.\nspread_track::Vector{Vector{Int16}}: Track of the support of the Pauli as it is acted upon by the layers of the circuit.\n\n\n\n\n\n","category":"type"},{"location":"internal/design/#QuantumACES.Pauli-internal-design","page":"design.jl","title":"QuantumACES.Pauli","text":"Pauli\n\nBoolean representation of a Pauli operator.\n\nFields\n\npauli::Vector{Bool}: The Pauli operator stored as a Boolean vector. The first qubit_num elements represent Pauli X on each qubit, the next qubit_num elements represent Pauli Z on each qubit, and the final element represents the sign.\nqubit_num::Int16: The number of qubits on which the Pauli operator acts; the length of the vector is 2 * qubit_num + 1.\n\n\n\n\n\n","category":"type"},{"location":"internal/design/#QuantumACES.complete_design-Tuple{Design}-internal-design","page":"design.jl","title":"QuantumACES.complete_design","text":"complete_design(d::Design; diagnostics::Bool = false)\n\nReturns a copy of the design d where the covariance matrix dictionary generates the full covariance matrix. Prints diagnostics if diagnostics is true.\n\n\n\n\n\n","category":"method"},{"location":"internal/design/#QuantumACES.generate_design-Union{Tuple{T}, Tuple{T, Vector{Vector{Int64}}}} where T<:AbstractCircuit-internal-design","page":"design.jl","title":"QuantumACES.generate_design","text":"generate_design(c::AbstractCircuit, tuple_set::Vector{Vector{Int}}; kwargs...)\ngenerate_design(c::AbstractCircuit, tuple_set_data::TupleSetData; kwargs...)\ngenerate_design(c::AbstractCircuit; kwargs...)\n\nReturns a Design object containing all relevant information describing the experimental design, including the design matrix.\n\nArguments\n\nc::AbstractCircuit: Circuit for which the design matrix is to be generated.\ntuple_set::Vector{Vector{Int}}: Tuple set arranging the circuit layers that is used to generate the experimental design.\ntuple_set_data::TupleSetData: TupleSetData object that generates the tuple set.\n\nKeyword arguments\n\nshot_weights::Union{Vector{Float64}, Nothing} = nothing: Shot weights for each tuple in the set, which must add to 1. When nothing, automatically generates the default shot weights.\nfull_covariance::Bool = true: If true, generates parameters to construct the full covariance matrix, else if false, only generates parameters to construct the terms on the diagonal.\nN_warn::Int = 3 * 10^4: Number of circuit eigenvalues above which to warn the user about certain keyword argument choices.\ndiagnostics::Bool = false: Whether to print diagnostic information.\nsave_data::Bool = false: Whether to save the design data.\n\n\n\n\n\n","category":"method"},{"location":"internal/design/#QuantumACES.update_noise-Union{Tuple{T}, Tuple{Design, T}} where T<:AbstractNoiseParameters-internal-design","page":"design.jl","title":"QuantumACES.update_noise","text":"update_noise(d::Design, noise_param::AbstractNoiseParameters)\n\nReturns a copy of design where the circuit has been updated with noise generated according to noise_param.\n\n\n\n\n\n","category":"method"},{"location":"internal/design/#Private-functions","page":"design.jl","title":"Private functions","text":"","category":"section"},{"location":"internal/design/","page":"design.jl","title":"design.jl","text":"Modules = [QuantumACES]\nPages = [\"design.jl\"]\nPublic = false","category":"page"},{"location":"internal/design/#QuantumACES.calc_consistency_set-Tuple{Vector{Mapping}}","page":"design.jl","title":"QuantumACES.calc_consistency_set","text":"calc_consistency_set(mapping_set::Vector{Mapping})\n\nReturns a list for each mapping in mapping_set of all other mappings with which it is simultaneously preparable and measurable, and hence tuple-consistent.\n\n\n\n\n\n","category":"method"},{"location":"internal/design/#QuantumACES.calc_covariance_dict-Union{Tuple{T}, Tuple{T, Vector{Mapping}, Vector{Vector{Int64}}, Bool}} where T<:AbstractCircuit","page":"design.jl","title":"QuantumACES.calc_covariance_dict","text":"calc_covariance_dict(c::AbstractCircuit, mapping_set::Vector{Mapping}, experiment_set::Vector{Vector{Int}}, full_covariance::Bool)\n\nReturns a dictionary with the requisite information to calculate the sparse circuit eigenvalue estimator covariance matrix for the arranged circuit c, with mappings mapping_set, when estimated by the experiments in experiment_set. If full_covariance is true, then this constructs the full covariance matrix, whereas if full_covariance is false, then this constructs only the diagonal terms of the covariance matrix.\n\n\n\n\n\n","category":"method"},{"location":"internal/design/#QuantumACES.calc_experiment_set-Tuple{Vector{Mapping}, Vector{Vector{Int64}}}","page":"design.jl","title":"QuantumACES.calc_experiment_set","text":"calc_experiment_set(mapping_set::Vector{Mapping}, consistency_set::Vector{Vector{Int}})\n\nReturns a set of experiments which simultaneously estimate the circuit eigenvalues corresponding to the mappings in mapping_set, whose tuple-consistency relations are described by consistency_set.\n\n\n\n\n\n","category":"method"},{"location":"internal/design/#QuantumACES.calc_mapping-Union{Tuple{T}, Tuple{Pauli, T}} where T<:AbstractCircuit","page":"design.jl","title":"QuantumACES.calc_mapping","text":"calc_mapping(initial::Pauli, c::AbstractCircuit)\n\nReturns a Mapping object for the Pauli initial when mapped by the circuit c.\n\n\n\n\n\n","category":"method"},{"location":"internal/design/#QuantumACES.calc_mapping_set-Tuple{T} where T<:AbstractCircuit","page":"design.jl","title":"QuantumACES.calc_mapping_set","text":"calc_mapping_set(c::AbstractCircuit)\n\nReturns a vector of Mapping objects for each single-qubit Pauli on the qubits in the circuit c, and each two-qubit Pauli supported on some gate in the circuit c.\n\n\n\n\n\n","category":"method"},{"location":"internal/design/#QuantumACES.get_experiment_layers-Union{Tuple{T}, Tuple{T, Vector{Mapping}, Vector{Vector{Int64}}}} where T<:AbstractCircuit","page":"design.jl","title":"QuantumACES.get_experiment_layers","text":"get_experiment_layers(c::AbstractCircuit, mapping_set::Vector{Mapping}, experiment_set::Vector{Vector{Int}})\n\nReturns circuit layers that prepare and measure the initial and final Paulis as given by the mappings in mapping_set, for each experiment in experiment set. If c has a partition field, this is used to generate all necessary sign configurations for the preparation layers.\n\n\n\n\n\n","category":"method"},{"location":"internal/design/#QuantumACES.get_meas_layer-Tuple{Pauli, Vector{Int64}}","page":"design.jl","title":"QuantumACES.get_meas_layer","text":"get_meas_layer(final::Pauli, final_support::Vector{Int})\n\nReturns a layer which measures the Pauli final, supported on the qubits in final_support.\n\n\n\n\n\n","category":"method"},{"location":"internal/design/#QuantumACES.get_pauli_prep_set-Tuple{Vector{Gate}, Int64}","page":"design.jl","title":"QuantumACES.get_pauli_prep_set","text":"get_pauli_prep_set(gates::Vector{Gate}, n::Int)\n\nReturns all weight-1 Paulis on all n qubits, as well as the weight-2 Paulis supported on some gate in gates.\n\n\n\n\n\n","category":"method"},{"location":"internal/design/#QuantumACES.get_prep_layer-Tuple{Pauli, Vector{Int64}}","page":"design.jl","title":"QuantumACES.get_prep_layer","text":"get_prep_layer(initial::Pauli, initial_support::Vector{Int})\n\nReturns a layer which prepares the Pauli initial, supported on the qubits in initial_support.\n\n\n\n\n\n","category":"method"},{"location":"internal/design/#QuantumACES.update_design_row!-Tuple{Vector{Int64}, Pauli, Layer, Dict{Gate, Int64}}","page":"design.jl","title":"QuantumACES.update_design_row!","text":"update_design_row!(design_row::Vector{Int}, pauli::Pauli, l::Layer, gate_index::Dict{Gate, Int})\n\nUpdates the design matrix row design_row according to the Pauli pauli for each gate in the layer l, using the gate index gate_index.\n\n\n\n\n\n","category":"method"},{"location":"internal/noise/","page":"noise.jl","title":"noise.jl","text":"CollapsedDocStrings = true","category":"page"},{"location":"internal/noise/#noise.jl","page":"noise.jl","title":"noise.jl","text":"","category":"section"},{"location":"internal/noise/#Public-functions","page":"noise.jl","title":"Public functions","text":"","category":"section"},{"location":"internal/noise/","page":"noise.jl","title":"noise.jl","text":"Modules = [QuantumACES]\nPages = [\"noise.jl\"]\nPrivate = false","category":"page"},{"location":"internal/noise/#QuantumACES.DepolarisingParameters-internal-noise","page":"noise.jl","title":"QuantumACES.DepolarisingParameters","text":"DepolarisingParameters\n\nParameterises a depolarising Pauli noise model.\n\nFields\n\nr_1::Float64: Single-qubit gate entanglement infidelity, the sum of all 3 non-identity Pauli error probabilities.\nr_2::Float64: Two-qubit gate entanglement infidelity, the sum of all 15 non-identity Pauli error probabilities.\nr_m::Float64: Measurement entanglement infidelity, the measurement error probability.\nnoise_name::String: Noise parameter name for saving data.\n\n\n\n\n\n","category":"type"},{"location":"internal/noise/#QuantumACES.LognormalParameters-internal-noise","page":"noise.jl","title":"QuantumACES.LognormalParameters","text":"LognormalParameters\n\nParameterises a log-normally random Pauli noise model.\n\nFields\n\nr_1::Float64: Average single-qubit gate entanglement infidelity, the sum of all 3 non-identity Pauli error probabilities.\nr_2::Float64: Average two-qubit gate entanglement infidelity, the sum of all 15 non-identity Pauli error probabilities.\nr_m::Float64: Average measurement entanglement infidelity, the measurement error probability.\ntotal_std_log::Float64: Approximate standard deviation of the logarithm of the entanglement infidelity across all gate types.\nseed::UInt64: Random seed used to generate the noise.\nnoise_name::String: Noise parameter name for saving data.\n\n\n\n\n\n","category":"type"},{"location":"internal/noise/#QuantumACES.get_dep_param-Tuple{Float64, Float64, Float64}-internal-noise","page":"noise.jl","title":"QuantumACES.get_dep_param","text":"get_dep_param(r_1::Float64, r_2::Float64, r_m::Float64)\n\nReturn a DepolarisingParameters object that parameterises a depolarising Pauli noise model with single-qubit, two-qubit, and measurement infidelities r_1, r_2, and r_m, respectively.\n\n\n\n\n\n","category":"method"},{"location":"internal/noise/#QuantumACES.get_gate_probabilities-Tuple{Vector{Gate}, DepolarisingParameters}-internal-noise","page":"noise.jl","title":"QuantumACES.get_gate_probabilities","text":"get_gate_probabilities(total_gates::Vector{Gate}, noise_param::DepolarisingParameters)\nget_gate_probabilities(total_gates::Vector{Gate}, noise_param::LognormalParameters)\n\nReturns a dictionary of the Pauli error probabilities for each gate in total_gates generated according to the noise parameters noise_param.\n\nThe order in which Pauli stores Pauli operators as bit strings orders the Pauli error probabilities for each gate. For single-qubit gates, the Pauli error probabilities are ordered as I, X, Z, Y. For two-qubit gates, the Pauli error probabilities are ordered as II, XI, IX, XX, ZI, YI, ZX, YX, IZ, XZ, IY, XY, ZZ, YZ, ZY, YY.\n\n\n\n\n\n","category":"method"},{"location":"internal/noise/#QuantumACES.get_log_param-NTuple{4, Float64}-internal-noise","page":"noise.jl","title":"QuantumACES.get_log_param","text":"get_log_param(r_1::Float64, r_2::Float64, r_m::Float64, total_std_log::Float64; seed::Union{UInt64, Nothing} = nothing)\n\nReturn a LognormalParameters object that parameterises a log-normally random Pauli noise model with average single-qubit, two-qubit, and measurement infidelities r_1, r_2, and r_m, respectively, approximate standard deviation of the logarithm of the entanglement infidelity total_std_log, and random seed seed, which is randomly generated if not supplied.\n\n\n\n\n\n","category":"method"},{"location":"internal/noise/#Private-functions","page":"noise.jl","title":"Private functions","text":"","category":"section"},{"location":"internal/noise/","page":"noise.jl","title":"noise.jl","text":"Modules = [QuantumACES]\nPages = [\"noise.jl\"]\nPublic = false","category":"page"},{"location":"internal/noise/#QuantumACES.get_gate_eigenvalues-Tuple{Dict{Gate, Vector{Float64}}, Vector{Gate}, Dict{Gate, Int64}, Int64}","page":"noise.jl","title":"QuantumACES.get_gate_eigenvalues","text":"get_gate_eigenvalues(gate_probabilities::Dict{Gate, Vector{Float64}}, total_gates::Vector{Gate}, gate_index::Dict{Gate, Int}, N::Int)\n\nReturns the eigenvalues corresponding to the supplied Pauli error probabilities gate_probabilities, ordered by the gates into a vector for the gates total_gates using the index data gate_index and N produced by index_gates.\n\n\n\n\n\n","category":"method"},{"location":"internal/optimise/","page":"optimise.jl","title":"optimise.jl","text":"CollapsedDocStrings = true","category":"page"},{"location":"internal/optimise/#optimise.jl","page":"optimise.jl","title":"optimise.jl","text":"","category":"section"},{"location":"internal/optimise/#Public-functions","page":"optimise.jl","title":"Public functions","text":"","category":"section"},{"location":"internal/optimise/","page":"optimise.jl","title":"optimise.jl","text":"Modules = [QuantumACES]\nPages = [\"optimise.jl\"]\nPrivate = false","category":"page"},{"location":"internal/optimise/#QuantumACES.optimise_design-Union{Tuple{T}, Tuple{T, TupleSetData}} where T<:AbstractCircuit-internal-optimise","page":"optimise.jl","title":"QuantumACES.optimise_design","text":"optimise_design(c::AbstractCircuit; options::OptimOptions = OptimOptions())\noptimise_design(c::AbstractCircuit, tuple_set_data::TupleSetData; options::OptimOptions = OptimOptions())\n\nReturns an optimised experimental design for the circuit c initialised with the tuple set data tuple_set_data. The optimisation is parameterised by the OptimOptions object options.\n\n\n\n\n\n","category":"method"},{"location":"internal/optimise/#QuantumACES.optimise_repetitions-Union{Tuple{T}, Tuple{T, TupleSetData}} where T<:AbstractCircuit-internal-optimise","page":"optimise.jl","title":"QuantumACES.optimise_repetitions","text":"optimise_repetitions(c::AbstractCircuit, tuple_set_data::TupleSetData; options::OptimOptions = OptimOptions())\n\nReturns the tuple set data after optimising the repetition numbers in the supplied tuple set data tuple_set_data for the circuit c. The optimisation is parameterised by the OptimOptions object options.\n\n\n\n\n\n","category":"method"},{"location":"internal/optimise/#QuantumACES.optimise_tuple_set-Tuple{Design, SparseArrays.SparseMatrixCSC{Float64, Int64}}-internal-optimise","page":"optimise.jl","title":"QuantumACES.optimise_tuple_set","text":"optimise_tuple_set(d::Design, covariance_log::SparseMatrixCSC{Float64, Int}; options::OptimOptions = OptimOptions())\n\nReturns versions of the design d and circuit log-eigenvalue estimator covariance matrix covariance_log after optimising the tuple set of the design with repeated excursions that grow and prune the tuple set. The optimisation is parameterised by the OptimOptions object options.\n\n\n\n\n\n","category":"method"},{"location":"internal/optimise/#Private-functions","page":"optimise.jl","title":"Private functions","text":"","category":"section"},{"location":"internal/optimise/","page":"optimise.jl","title":"optimise.jl","text":"Modules = [QuantumACES]\nPages = [\"optimise.jl\"]\nPublic = false","category":"page"},{"location":"internal/optimise/#QuantumACES.grow_design-Tuple{Design, SparseArrays.SparseMatrixCSC{Float64, Int64}, Vector{Int64}}","page":"optimise.jl","title":"QuantumACES.grow_design","text":"grow_design(d::Design, covariance_log::SparseMatrixCSC{Float64, Int}, circuit_tuple::Vector{Int})\n\nReturns versions of the design d and circuit log-eigenvalue estimator covariance matrix covariance_log after adding the tuple circuit_tuple to the tuple set of the design.\n\n\n\n\n\n","category":"method"},{"location":"internal/optimise/#QuantumACES.grow_design_excursion-Tuple{Design, SparseArrays.SparseMatrixCSC{Float64, Int64}}","page":"optimise.jl","title":"QuantumACES.grow_design_excursion","text":"grow_design_excursion(d::Design, covariance_log::SparseMatrixCSC{Float64, Int}; options::OptimOptions = OptimOptions())\n\nReturns versions of the design d and circuit log-eigenvalue estimator covariance matrix covariance_log after optimising the tuple set of the design with an excursion that grows the tuple set. The optimisation is parameterised by the OptimOptions object options.\n\n\n\n\n\n","category":"method"},{"location":"internal/optimise/#QuantumACES.optimal_expectation-Union{Tuple{T}, Tuple{TupleSetData, Dict{Vector{Int64}, Float64}, T}} where T<:AbstractCircuit","page":"optimise.jl","title":"QuantumACES.optimal_expectation","text":"optimal_expectation(tuple_set_data::TupleSetData, expectation_dict::Dict{Vector{Int}, Float64}, c::AbstractCircuit; options::OptimOptions = OptimOptions())\n\nReturns the optimised figure of merit, and a dictionary of stored values, for the circuit c with tuple set data tuple_set_data, with optimised shot weights. The optimisation is parameterised by the OptimOptions object options.\n\n\n\n\n\n","category":"method"},{"location":"internal/optimise/#QuantumACES.prune_design-Tuple{Design, SparseArrays.SparseMatrixCSC{Float64, Int64}, Int64}","page":"optimise.jl","title":"QuantumACES.prune_design","text":"prune_design(d::Design, covariance_log::SparseMatrixCSC{Float64, Int}, prune_idx::Int; update_weights::Bool = true)\n\nReturns versions of the design d and circuit log-eigenvalue estimator covariance matrix covariance_log after removing the tuple at index prune_idx from the tuple set of the design. If update_weights is false, do not update the shot weight factor for the covariance matrix.\n\n\n\n\n\n","category":"method"},{"location":"internal/optimise/#QuantumACES.prune_design_excursion-Tuple{Design, SparseArrays.SparseMatrixCSC{Float64, Int64}}","page":"optimise.jl","title":"QuantumACES.prune_design_excursion","text":"prune_design_excursion(d::Design, covariance_log::SparseMatrixCSC{Float64, Int}; options::OptimOptions = OptimOptions())\n\nReturns versions of the design d and circuit log-eigenvalue estimator covariance matrix covariance_log after optimising the tuple set of the design with an excursion that prunes the tuple set. The optimisation is parameterised by the OptimOptions object options.\n\n\n\n\n\n","category":"method"},{"location":"internal/optimise/#QuantumACES.random_tuple-Union{Tuple{T}, Tuple{T, Int64, Float64, Bool}} where T<:AbstractCircuit","page":"optimise.jl","title":"QuantumACES.random_tuple","text":"random_tuple(c::AbstractCircuit, tuple_length::Int, s::Float64, mirror::Bool)\n\nReturns a random tuple for the circuit c with length tuple_length. The generation is parameterised by the Zipf power s and the tuple is mirrored if mirror is true. Adds random indices to the tuple, repeated a number of times following a generalised Zipf distribution. For dynamically decoupled circuits, this function ensures that two-qubit gate layers are always followed by some other layer in the tuple.\n\n\n\n\n\n","category":"method"},{"location":"internal/optimise/#QuantumACES.sample_zipf-Tuple{Int64, Float64}","page":"optimise.jl","title":"QuantumACES.sample_zipf","text":"sample_zipf(N::Int, s::Float64)\n\nReturns a sample from a generalised Zipf distribution supported on 1 to N parameterised by the power s.\n\n\n\n\n\n","category":"method"},{"location":"internal/optimise/#QuantumACES.step_repetitions-Union{Tuple{T}, Tuple{TupleSetData, Dict{Vector{Int64}, Float64}, Vector{Int64}, Int64, T}} where T<:AbstractCircuit","page":"optimise.jl","title":"QuantumACES.step_repetitions","text":"step_repetitions(tuple_set_data::TupleSetData, expectation_dict::Dict{Vector{Int}, Float64}, step_tracker::Vector{Int}, coordinate_idx::Int, c::AbstractCircuit; options::OptimOptions = OptimOptions())\n\nReturns the tuple set data, a dictionary of stored figure of merit, and the step tracker after stepping the repetition number for the tuple set data tuple_set_data at the index coordinate_idx for the circuit c. The optimisation is parameterised by the OptimOptions object options.\n\n\n\n\n\n","category":"method"},{"location":"internal/optimise/#QuantumACES.tuple_append!-Tuple{Vector{Int64}, Int64, Float64, Vector{Int64}, Vector{Int64}, Vector{Int64}}","page":"optimise.jl","title":"QuantumACES.tuple_append!","text":"tuple_append!(circuit_tuple::Vector{Int}, tuple_length::Int, s::Float64, unique_indices::Vector{Int}, two_qubit_indices::Vector{Int}, other_indices::Vector{Int})\n\nAppends a random index from unique_indices to the tuple circuit_tuple, repeated a number of times determined by a Zipf distribution on 1 to tuple_length with power s. Ensures that two-qubit layers, whose indices are given by two_qubit_indices, are always followed by other layers in the tuple, whose indices are given by other_indices.\n\n\n\n\n\n","category":"method"},{"location":"internal/optimise/#QuantumACES.tuple_append!-Tuple{Vector{Int64}, Int64, Float64, Vector{Int64}}","page":"optimise.jl","title":"QuantumACES.tuple_append!","text":"tuple_append!(circuit_tuple::Vector{Int}, tuple_length::Int, s::Float64, unique_indices::Vector{Int})\n\nAppends a random index from unique_indices to the tuple circuit_tuple, repeated a number of times determined by a Zipf distribution on 1 to tuple_length with power s.\n\n\n\n\n\n","category":"method"},{"location":"internal/merit/","page":"merit.jl","title":"merit.jl","text":"CollapsedDocStrings = true","category":"page"},{"location":"internal/merit/#merit.jl","page":"merit.jl","title":"merit.jl","text":"","category":"section"},{"location":"internal/merit/#Public-functions","page":"merit.jl","title":"Public functions","text":"","category":"section"},{"location":"internal/merit/","page":"merit.jl","title":"merit.jl","text":"Modules = [QuantumACES]\nPages = [\"merit.jl\"]\nPrivate = false","category":"page"},{"location":"internal/merit/#QuantumACES.Merit-internal-merit","page":"merit.jl","title":"QuantumACES.Merit","text":"Merit\n\nMerit parameters for an experimental design.\n\nFields\n\ncircuit_param::AbstractCircuitParameters: Circuit parameters.\nnoise_param::AbstractNoiseParameters: Noise parameters.\nls_type::Symbol: Type of least squares estimator for which the merit is reported.\ntuple_set::Vector{Vector{Int}}: Set of tuples which arrange the circuit layers.\ntuple_set_data::TupleSetData: TupleSetData object that generates the tuple set.\ntuple_times::Vector{Float64}: Time taken to implement the circuit corresponding to each tuple, normalised according to the basic tuple set.\nshot_weights::Vector{Float64}: Shot weights for each tuple in the set, which add to 1.\nexperiment_numbers::Vector{Int}: Number of experiments for each tuple in the set.\nexperiment_number::Int: Total number of experiments.\nG::Int: Total number of gates.\nN::Int: Number of gate eigenvalues.\nexpectation::Float64: Expected normalised RMS error for the gate eigenvalue estimator vector.\nvariance::Float64: Normalised RMS error variance for the gate eigenvalue estimator vector.\neigenvalues::Vector{Float64}: Eigenvalues of the gate eigenvalue estimator covariance matrix.\ncond_num::Float64: Condition number of the design matrix, the ratio of the largest and smallest singular values.\npinv_norm::Float64: Pseudoinverse norm of the design matrix, the inverse of the smallest singular value.\n\n\n\n\n\n","category":"type"},{"location":"internal/merit/#QuantumACES.calc_covariance_log-Tuple{Design}-internal-merit","page":"merit.jl","title":"QuantumACES.calc_covariance_log","text":"calc_covariance_log(d::Design; warning::Bool = true)\n\nReturns the covariance matrix of the circuit log-eigenvalues for the design d. If warning is true, warns that if d.full_covariance is false this will only generate the diagonal of the covariance matrix.\n\n\n\n\n\n","category":"method"},{"location":"internal/merit/#QuantumACES.calc_gls_merit-Tuple{Design}-internal-merit","page":"merit.jl","title":"QuantumACES.calc_gls_merit","text":"calc_gls_merit(d::Design)\n\nReturns the Merit object for the generalised least squares (GLS) estimator corresponding to the design d.\n\n\n\n\n\n","category":"method"},{"location":"internal/merit/#QuantumACES.calc_gls_moments-Tuple{Design, SparseArrays.SparseMatrixCSC{Float64, Int64}}-internal-merit","page":"merit.jl","title":"QuantumACES.calc_gls_moments","text":"calc_gls_moments(d::Design, covariance_log::SparseMatrixCSC{Float64, Int})\n\nReturns the expectation and variance of the normalised RMS error for the generalised least squares (GLS) estimator corresponding to the design d with circuit log-eigenvalue estimator covariance matrix covariance_log.\n\n\n\n\n\n","category":"method"},{"location":"internal/merit/#QuantumACES.calc_ls_merit-Tuple{Design, Symbol}-internal-merit","page":"merit.jl","title":"QuantumACES.calc_ls_merit","text":"calc_ls_merit(d::Design, ls_type::Symbol)\n\nReturns the Merit object for the least squares estimator specified by ls_type (:gls, :wls, or :ols) corresponding to the design d.\n\n\n\n\n\n","category":"method"},{"location":"internal/merit/#QuantumACES.calc_ls_moments-Tuple{Design, SparseArrays.SparseMatrixCSC{Float64, Int64}, Symbol}-internal-merit","page":"merit.jl","title":"QuantumACES.calc_ls_moments","text":"calc_ls_moments(d::Design, covariance_log::SparseMatrixCSC{Float64, Int}, ls_type::Symbol)\n\nReturns the expectation and variance of the normalised RMS error for the least squares estimator specified by ls_type (:gls, :wls, or :ols) corresponding to the design d with circuit log-eigenvalue estimator covariance matrix covariance_log.\n\n\n\n\n\n","category":"method"},{"location":"internal/merit/#QuantumACES.calc_merit_set-Tuple{Design}-internal-merit","page":"merit.jl","title":"QuantumACES.calc_merit_set","text":"calc_ls_merit(d::Design, ls_type::Symbol)\n\nReturns Merit objects for all three least squares estimators (generalised, weighted, and ordinary least squares) corresponding to the design d.\n\n\n\n\n\n","category":"method"},{"location":"internal/merit/#QuantumACES.calc_ols_merit-Tuple{Design}-internal-merit","page":"merit.jl","title":"QuantumACES.calc_ols_merit","text":"calc_ols_merit(d::Design)\n\nReturns the Merit object for the ordinary least squares (OLS) estimator corresponding to the design d.\n\n\n\n\n\n","category":"method"},{"location":"internal/merit/#QuantumACES.calc_ols_moments-Tuple{Design, SparseArrays.SparseMatrixCSC{Float64, Int64}}-internal-merit","page":"merit.jl","title":"QuantumACES.calc_ols_moments","text":"calc_ols_moments(d::Design, covariance_log::SparseMatrixCSC{Float64, Int})\n\nReturns the expectation and variance of the normalised RMS error for the ordinary least squares (OLS) estimator corresponding to the design d with circuit log-eigenvalue estimator covariance matrix covariance_log.\n\n\n\n\n\n","category":"method"},{"location":"internal/merit/#QuantumACES.calc_wls_merit-Tuple{Design}-internal-merit","page":"merit.jl","title":"QuantumACES.calc_wls_merit","text":"calc_wls_merit(d::Design)\n\nReturns the Merit object for the weighted least squares (WLS) estimator corresponding to the design d.\n\n\n\n\n\n","category":"method"},{"location":"internal/merit/#QuantumACES.calc_wls_moments-Tuple{Design, SparseArrays.SparseMatrixCSC{Float64, Int64}}-internal-merit","page":"merit.jl","title":"QuantumACES.calc_wls_moments","text":"calc_wls_moments(d::Design, covariance_log::SparseMatrixCSC{Float64, Int})\n\nReturns the expectation and variance of the normalised RMS error for the weighted least squares (WLS) estimator corresponding to the design d with circuit log-eigenvalue estimator covariance matrix covariance_log.\n\n\n\n\n\n","category":"method"},{"location":"internal/merit/#QuantumACES.nrmse_pdf-Tuple{Vector{Float64}, Vector{Float64}}-internal-merit","page":"merit.jl","title":"QuantumACES.nrmse_pdf","text":"nrmse_pdf(cov_eigenvalues::Vector{Float64}, nrmse_values::Vector{Float64}; epsilon::Float64 = 1e-5)\n\nReturns the probability density function (PDF) for the normalised RMS error (NRMSE) of the gate eigenvalue estimator vector, which follows a generalised chi-squared distribution and whose covariance matrix has eigenvalues cov_eigenvalues, at the coordinates specified by nrmse_values. Does not calculate values when the normal approximation to the PDF is less than a factor of epsilon of its maximum value.\n\nCalculation follows Eq. 3.2 of Computing the distribution of quadratic forms in normal variables by J. P. Imhof (1961).\n\n\n\n\n\n","category":"method"},{"location":"internal/merit/#Private-functions","page":"merit.jl","title":"Private functions","text":"","category":"section"},{"location":"internal/merit/","page":"merit.jl","title":"merit.jl","text":"Modules = [QuantumACES]\nPages = [\"merit.jl\"]\nPublic = false","category":"page"},{"location":"internal/merit/#QuantumACES.calc_covariance-Tuple{Design, Vector{Float64}, Vector{Float64}}","page":"merit.jl","title":"QuantumACES.calc_covariance","text":"calc_covariance(d::Design, eigenvalues::Vector{Float64}, gate_eigenvalues::Vector{Float64}; warning::Bool = true)\ncalc_covariance(d::Design, eigenvalues::Vector{Float64}; warning::Bool = true)\ncalc_covariance(d::Design; warning::Bool = true)\n\nReturns the circuit eigenvalue estimator covariance matrix for the design d with circuit eigenvalues eigenvalues and gate eigenvalues gate_eigenvalues. If warning is true, warns that if d.full_covariance is false this will only generate the diagonal of the covariance matrix.\n\n\n\n\n\n","category":"method"},{"location":"internal/merit/#QuantumACES.calc_eigenvalues_covariance-Tuple{Design}","page":"merit.jl","title":"QuantumACES.calc_eigenvalues_covariance","text":"calc_eigenvalues_covariance(d::Design; warning::Bool = true)\n\nReturns the circuit eigenvalues and circuit eigenvalue estimator covariance matrix for the design d. If warning is true, warns that if d.full_covariance is false this will only generate the diagonal of the covariance matrix.\n\n\n\n\n\n","category":"method"},{"location":"internal/merit/#QuantumACES.calc_gls_covariance-Tuple{Design, SparseArrays.SparseMatrixCSC{Float64, Int64}}","page":"merit.jl","title":"QuantumACES.calc_gls_covariance","text":"calc_gls_covariance(d::Design, covariance_log::SparseMatrixCSC{Float64, Int})\n\nReturns the gate eigenvalue estimator covariance matrix for the generalised least squares (GLS) estimator corresponding to the design d with circuit log-eigenvalue estimator covariance matrix covariance_log.\n\n\n\n\n\n","category":"method"},{"location":"internal/merit/#QuantumACES.calc_ls_covariance-Tuple{Design, SparseArrays.SparseMatrixCSC{Float64, Int64}, Symbol}","page":"merit.jl","title":"QuantumACES.calc_ls_covariance","text":"calc_ls_covariance(d::Design, covariance_log::SparseMatrixCSC{Float64, Int}, ls_type::Symbol)\n\nReturns the gate eigenvalue estimator covariance matrix for the least squares estimator specified by ls_type (:gls, :wls, or :ols) corresponding to the design d with circuit log-eigenvalue estimator covariance matrix covariance_log.\n\n\n\n\n\n","category":"method"},{"location":"internal/merit/#QuantumACES.calc_ols_covariance-Tuple{Design, SparseArrays.SparseMatrixCSC{Float64, Int64}}","page":"merit.jl","title":"QuantumACES.calc_ols_covariance","text":"calc_ols_covariance(d::Design, covariance_log::SparseMatrixCSC{Float64, Int})\n\nReturns the gate eigenvalue estimator covariance matrix for the ordinary least squares (OLS) estimator corresponding to the design d with circuit log-eigenvalue estimator covariance matrix covariance_log.\n\n\n\n\n\n","category":"method"},{"location":"internal/merit/#QuantumACES.calc_wls_covariance-Tuple{Design, SparseArrays.SparseMatrixCSC{Float64, Int64}}","page":"merit.jl","title":"QuantumACES.calc_wls_covariance","text":"calc_wls_covariance(d::Design, covariance_log::SparseMatrixCSC{Float64, Int})\n\nReturns the gate eigenvalue estimator covariance matrix for the weighted least squares (WLS) estimator corresponding to the design d with circuit log-eigenvalue estimator covariance matrix covariance_log.\n\n\n\n\n\n","category":"method"},{"location":"internal/merit/#QuantumACES.nrmse_moments-Tuple{Vector{Float64}}","page":"merit.jl","title":"QuantumACES.nrmse_moments","text":"nrmse_moments(cov_eigenvalues::Vector{Float64})\n\nReturns the expectation and variance of the normalised RMS error, as determined by the eigenvalues cov_eigenvalues of the gate eigenvalue estimator covariance matrix.\n\n\n\n\n\n","category":"method"},{"location":"internal/merit/#QuantumACES.nrmse_pdf_integrand-Tuple{Float64, Float64, Vector{Float64}}","page":"merit.jl","title":"QuantumACES.nrmse_pdf_integrand","text":"nrmse_pdf_integrand(u::Float64, x::Float64, norm_cov_eigenvalues::Vector{Float64})\n\nReturns the integrand of the Imhof method CDF for the distribution of the NRMSE.\n\nCalculation follows Eq. 3.2 of Computing the distribution of quadratic forms in normal variables by J. P. Imhof (1961).\n\n\n\n\n\n","category":"method"},{"location":"internal/merit/#QuantumACES.sparse_covariance_inv-Tuple{SparseArrays.SparseMatrixCSC{Float64, Int64}, Vector{Int64}}","page":"merit.jl","title":"QuantumACES.sparse_covariance_inv","text":"sparse_covariance_inv(covariance_log::SparseMatrixCSC{Float64, Int}, mapping_lengths::Vector{Int})\n\nReturns the inverse of the sparse block diagonal circuit log-eigenvalue estimator covariance matrix covariance_log, where the block sizes are specified by mapping_lengths.\n\n\n\n\n\n","category":"method"},{"location":"public/","page":"Public API","title":"Public API","text":"CollapsedDocStrings = true","category":"page"},{"location":"public/#Public-API","page":"Public API","title":"Public API","text":"","category":"section"},{"location":"public/","page":"Public API","title":"Public API","text":"Documentation for the public API of QuantumACES.jl.","category":"page"},{"location":"public/","page":"Public API","title":"Public API","text":"To use internal API, which is documented in the internal API section, import the module by running the following.","category":"page"},{"location":"public/","page":"Public API","title":"Public API","text":"import QuantumACES as ACES","category":"page"},{"location":"public/#QuantumACES.jl","page":"Public API","title":"QuantumACES.jl","text":"","category":"section"},{"location":"public/","page":"Public API","title":"Public API","text":"Modules = [QuantumACES]\nPages = [\"QuantumACES.jl\"]\nPrivate = false","category":"page"},{"location":"public/#QuantumACES.QuantumACES","page":"Public API","title":"QuantumACES.QuantumACES","text":"QuantumACES.jl is a package for designing and simulating scalable and performant Pauli noise characterisation experiments for stabiliser circuits with averaged circuit eigenvalue sampling (ACES). It is particularly interested in characterising the noise associated with fault-tolerant gadgets in the context of topological quantum error correcting codes, such as surface code syndrome extraction circuits.\n\n\n\n\n\n","category":"module"},{"location":"public/#QuantumACES.AbstractCircuit","page":"Public API","title":"QuantumACES.AbstractCircuit","text":"AbstractCircuit\n\nCircuits should be stored in a subtype T <: AbstractCircuit.\n\nCircuits should be generated by a method of get_circuit, and prepare_circuit is a helpful function for writing such a method.\n\nNecessary fields\n\ncircuit_param::AbstractCircuitParameters: Circuit parameters.\ncircuit::Vector{Layer}: Circuit arranged by the tuple.\ncircuit_tuple::Vector{Int}: Tuple which arranges the order of the circuit layers; this is initialised as trivial.\nqubit_num::Int: Number of qubits in the circuit.\nunique_layer_indices::Vector{Int}: Unique layer indices of the circuit, which become meaningless and are removed the circuit is arranged by the tuple.\nlayer_types::Vector{Symbol}: Types of the layers in the circuit, used for layer times and dynamical decoupling.\nlayer_times::Vector{Float64}: Times taken to implement each layer in the circuit, as well as measurement and reset.\ngates::Vector{Gate}: Gates in the circuit arranged by the tuple.\ntotal_gates::Vector{Gate}: Gates in the original circuit, which includes noisy preparations if add_prep and noisy measurements if add_meas.\ngate_index::Dict{Gate, Int}: Index of the gate eigenvalues for each gates in the original circuit.\nN::Int: Number of gate eigenvalues.\nnoise_param::AbstractNoiseParameters: Noise parameters.\ngate_probabilities::Dict{Gate, Vector{Float64}}: Pauli error probabilities for each gate, stored as a dictionary.\ngate_eigenvalues::Vector{Float64}: Eigenvalues for each gate, stored as a vector whose order is determined by gate_index.\nadd_prep::Bool: Whether to treat preparations as noisy and characterise the associated noise, which should default to false; a full-rank design cannot be produced if both add_prep and add_meas are true.\nadd_meas::Bool: Whether to treat measurements as noisy and characterise the associated noise, which should default to true; a full-rank design cannot be produced if both add_prep and add_meas are true.\n\nOptional fields\n\npartition::Tuple{Vector{Int}, Vector{Int}}: A partition of the qubits into two sets such that two-qubit gates act only between the sets, which allows for easy preparation of sign configurations for Pauli eigenstates; for example, data and ancilla qubits for a syndrome extraction circuit.\n\n\n\n\n\n","category":"type"},{"location":"public/#QuantumACES.AbstractCircuitParameters","page":"Public API","title":"QuantumACES.AbstractCircuitParameters","text":"AbstractCircuitParameters\n\nCircuit parameters should be stored in a subtype T <: AbstractCircuitParameters.\n\nThen add a method to get_circuit that generates a circuit according to these parameters. Such a circuit should either be a Circuit type, or a subtype T <: AbstractCircuit.\n\nNecessary fields\n\nlayer_time_dict::Dict{Symbol, Float64}: Dictionary of the times taken to implement the different types of layers in the circuit, including the time for measurement and reset.\ncircuit_name::String: Name of the circuit, which should implicitly describe parameter settings.\n\n\n\n\n\n","category":"type"},{"location":"public/#QuantumACES.AbstractNoiseParameters","page":"Public API","title":"QuantumACES.AbstractNoiseParameters","text":"AbstractNoiseParameters\n\nNoise parameters should be stored in a subtype T <: AbstractNoiseParameters.\n\nNoise models should be generated by a method of get_gate_probabilities, which generates Pauli error probabilities for the supplied gates according to some supplied noise parameters.\n\nNecessary fields\n\nnoise_name::String: Name of the noise model, which should implicitly describe parameter settings.\n\n\n\n\n\n","category":"type"},{"location":"public/#QuantumACES.AbstractScalingData","page":"Public API","title":"QuantumACES.AbstractScalingData","text":"AbstractScalingData\n\nScaling data for the figure of merit should be stored in a subtype T <: AbstractScalingData.\n\nNecessary fields\n\ncircuit_param::AbstractCircuitParameters: Circuit parameters.\nnoise_param::AbstractNoiseParameters: Noise parameters.\ntuple_set::Vector{Vector{Int}}: Set of tuples which arrange the circuit layers.\ntuple_set_data::TupleSetData: TupleSetData object that generates the tuple set.\nshot_weights::Vector{Float64}: Shot weights for each tuple in the set, which add to 1.\nls_type::Symbol: Type of least squares estimator for which the scaling is calculated.\n\n\n\n\n\n","category":"type"},{"location":"public/#tableau.jl","page":"Public API","title":"tableau.jl","text":"","category":"section"},{"location":"public/","page":"Public API","title":"Public API","text":"Modules = [QuantumACES]\nPages = [\"tableau.jl\"]\nPrivate = false","category":"page"},{"location":"public/#QuantumACES.Gate","page":"Public API","title":"QuantumACES.Gate","text":"Gate\n\nA gate in a stabiliser circuit.\n\nFields\n\ntype::String: String describing the gate type.\nindex::Int32: The index labelling the unique layer occurrences of the gate in a circuit.\ntargets::Vector{Int16}: The qubit targets of the gate.\n\nSupported gates\n\nH: Hadamard gate.\nS: Phase gate.\nCX or CNOT: Controlled-X gate.\nCZ: Controlled-Z gate.\nI: Identity gate.\nZ: Pauli Z gate.\nX: Pauli X gate.\nY: Pauli Y gate.\nII: Two-qubit identity gate.\nAB: Two-qubit Pauli gate, where A and B are Paulis Z, X, or Y.\nSQRT_AB: Two-qubit Pauli rotation, where A and B are Paulis Z, X, or Y.\nSQRT_AB_DAG : Two-qubit Pauli rotation, where A and B are Paulis Z, X, or Y.\nPZ+: Prepare the Pauli +Z eigenstate.\nPZ-: Prepare the Pauli -Z eigenstate.\nPX+: Prepare the Pauli +X eigenstate.\nPX-: Prepare the Pauli -X eigenstate.\nPY+: Prepare the Pauli +Y eigenstate.\nPY-: Prepare the Pauli -Y eigenstate.\nM or MZ: Measure in the computational Pauli Z basis.\nMX: Measure in the Pauli X basis.\nMY: Measure in the Pauli Y basis.\nR: Reset to the computational Z basis.\n\n\n\n\n\n","category":"type"},{"location":"public/#QuantumACES.Layer","page":"Public API","title":"QuantumACES.Layer","text":"Layer\n\nA layer of gates in a stabiliser circuit. Gates in a layer are simultaneously implemented by the device, and act on disjoint sets of qubits such that they trivially commute with each other.\n\nFields\n\nlayer::Vector{Gate}: The gates in the layer.\nqubit_num::Int16: The number of qubits in the circuit.\n\n\n\n\n\n","category":"type"},{"location":"public/#QuantumACES.Tableau","page":"Public API","title":"QuantumACES.Tableau","text":"Tableau\n\nA tableau representation of a stabiliser state.\n\nStabiliser circuit simulations follow Improved simulation of stabilizer circuits by S. Aaronson and D. Gottesman (2004).\n\nFields\n\ntableau::Matrix{Bool}: The tableau representation of the stabiliser state.\nqubit_num::Int16: The number of qubits in the stabiliser state.\n\n\n\n\n\n","category":"type"},{"location":"public/#QuantumACES.apply!-Tuple{Tableau, Layer}","page":"Public API","title":"QuantumACES.apply!","text":"apply!(t::Tableau, l::Layer; return_measurements::Bool = false)\n\nPerform on the tableau t all gates in the layer l, and return the list of measurement outcomes if return_measurements is true.\n\n\n\n\n\n","category":"method"},{"location":"public/#QuantumACES.make_layer-Tuple{String, Vector{Int64}, Int64}","page":"Public API","title":"QuantumACES.make_layer","text":"make_layer(gate_type::String, range::Vector{Int}, n::Int)\n\nReturns a layer of single-qubit gate_type gates acting on the qubits in range, where the layer acts on n qubits.\n\n\n\n\n\n","category":"method"},{"location":"public/#QuantumACES.make_layer-Tuple{String, Vector{Vector{Int64}}, Int64}","page":"Public API","title":"QuantumACES.make_layer","text":"make_layer(gate_type::String, range_set::Vector{Vector{Int}}, n::Int)\n\nReturns a layer of gate_type gates, each acting on the qubits in range_set, where the layer acts on n qubits.\n\n\n\n\n\n","category":"method"},{"location":"public/#QuantumACES.make_layer-Tuple{Vector{String}, Vector{Vector{Int64}}, Int64}","page":"Public API","title":"QuantumACES.make_layer","text":"make_layer(gate_types::Vector{String}, ranges::Vector{Vector{Int}}, n::Int)\n\nReturns a layer of single-qubit gates, with gate types specified by gate_types and the qubits upon which they act specified by ranges, where the layer acts on n qubits.\n\n\n\n\n\n","category":"method"},{"location":"public/#QuantumACES.pad_layer-Tuple{Layer}","page":"Public API","title":"QuantumACES.pad_layer","text":"pad_layer(l::Layer)\n\nReturns a copy of the layer l padded by single-qubit identity gates that act on each of the qubits not already acted upon by some gate in the layer.\n\n\n\n\n\n","category":"method"},{"location":"public/#noise.jl","page":"Public API","title":"noise.jl","text":"","category":"section"},{"location":"public/","page":"Public API","title":"Public API","text":"Modules = [QuantumACES]\nPages = [\"noise.jl\"]\nPrivate = false","category":"page"},{"location":"public/#QuantumACES.DepolarisingParameters","page":"Public API","title":"QuantumACES.DepolarisingParameters","text":"DepolarisingParameters\n\nParameterises a depolarising Pauli noise model.\n\nFields\n\nr_1::Float64: Single-qubit gate entanglement infidelity, the sum of all 3 non-identity Pauli error probabilities.\nr_2::Float64: Two-qubit gate entanglement infidelity, the sum of all 15 non-identity Pauli error probabilities.\nr_m::Float64: Measurement entanglement infidelity, the measurement error probability.\nnoise_name::String: Noise parameter name for saving data.\n\n\n\n\n\n","category":"type"},{"location":"public/#QuantumACES.LognormalParameters","page":"Public API","title":"QuantumACES.LognormalParameters","text":"LognormalParameters\n\nParameterises a log-normally random Pauli noise model.\n\nFields\n\nr_1::Float64: Average single-qubit gate entanglement infidelity, the sum of all 3 non-identity Pauli error probabilities.\nr_2::Float64: Average two-qubit gate entanglement infidelity, the sum of all 15 non-identity Pauli error probabilities.\nr_m::Float64: Average measurement entanglement infidelity, the measurement error probability.\ntotal_std_log::Float64: Approximate standard deviation of the logarithm of the entanglement infidelity across all gate types.\nseed::UInt64: Random seed used to generate the noise.\nnoise_name::String: Noise parameter name for saving data.\n\n\n\n\n\n","category":"type"},{"location":"public/#QuantumACES.get_dep_param-Tuple{Float64, Float64, Float64}","page":"Public API","title":"QuantumACES.get_dep_param","text":"get_dep_param(r_1::Float64, r_2::Float64, r_m::Float64)\n\nReturn a DepolarisingParameters object that parameterises a depolarising Pauli noise model with single-qubit, two-qubit, and measurement infidelities r_1, r_2, and r_m, respectively.\n\n\n\n\n\n","category":"method"},{"location":"public/#QuantumACES.get_gate_probabilities-Tuple{Vector{Gate}, DepolarisingParameters}","page":"Public API","title":"QuantumACES.get_gate_probabilities","text":"get_gate_probabilities(total_gates::Vector{Gate}, noise_param::DepolarisingParameters)\nget_gate_probabilities(total_gates::Vector{Gate}, noise_param::LognormalParameters)\n\nReturns a dictionary of the Pauli error probabilities for each gate in total_gates generated according to the noise parameters noise_param.\n\nThe order in which Pauli stores Pauli operators as bit strings orders the Pauli error probabilities for each gate. For single-qubit gates, the Pauli error probabilities are ordered as I, X, Z, Y. For two-qubit gates, the Pauli error probabilities are ordered as II, XI, IX, XX, ZI, YI, ZX, YX, IZ, XZ, IY, XY, ZZ, YZ, ZY, YY.\n\n\n\n\n\n","category":"method"},{"location":"public/#QuantumACES.get_log_param-NTuple{4, Float64}","page":"Public API","title":"QuantumACES.get_log_param","text":"get_log_param(r_1::Float64, r_2::Float64, r_m::Float64, total_std_log::Float64; seed::Union{UInt64, Nothing} = nothing)\n\nReturn a LognormalParameters object that parameterises a log-normally random Pauli noise model with average single-qubit, two-qubit, and measurement infidelities r_1, r_2, and r_m, respectively, approximate standard deviation of the logarithm of the entanglement infidelity total_std_log, and random seed seed, which is randomly generated if not supplied.\n\n\n\n\n\n","category":"method"},{"location":"public/#circuit.jl","page":"Public API","title":"circuit.jl","text":"","category":"section"},{"location":"public/","page":"Public API","title":"Public API","text":"Modules = [QuantumACES]\nPages = [\"circuit.jl\"]\nPrivate = false","category":"page"},{"location":"public/#QuantumACES.Circuit","page":"Public API","title":"QuantumACES.Circuit","text":"Circuit\n\nCircuit information, including noise parameters.\n\nFields\n\ncircuit_param::AbstractCircuitParameters: Circuit parameters.\ncircuit::Vector{Layer}: Circuit arranged by the tuple.\ncircuit_tuple::Vector{Int}: Tuple which arranges the order of the circuit layers; this is initialised as trivial.\nqubit_num::Int: Number of qubits in the circuit.\nunique_layer_indices::Vector{Int}: Unique layer indices of the circuit, which become meaningless and are removed the circuit is arranged by the tuple.\nlayer_types::Vector{Symbol}: Types of the layers in the circuit, used for layer times and dynamical decoupling.\nlayer_times::Vector{Float64}: Times taken to implement each layer in the circuit, as well as measurement and reset.\ngates::Vector{Gate}: Gates in the circuit arranged by the tuple.\ntotal_gates::Vector{Gate}: Gates in the original circuit, which includes noisy preparations if add_prep and noisy measurements if add_meas.\ngate_index::Dict{Gate, Int}: Index of the gate eigenvalues for each gates in the original circuit.\nN::Int: Number of gate eigenvalues.\nnoise_param::AbstractNoiseParameters: Noise parameters.\ngate_probabilities::Dict{Gate, Vector{Float64}}: Pauli error probabilities for each gate, stored as a dictionary.\ngate_eigenvalues::Vector{Float64}: Eigenvalues for each gate, stored as a vector whose order is determined by gate_index.\nadd_prep::Bool: Whether to treat preparations as noisy and characterise the associated noise, defaulting to false; a full-rank design cannot be produced if both add_prep and add_meas are true.\nadd_meas::Bool: Whether to treat measurements as noisy and characterise the associated noise, defaulting to true; a full-rank design cannot be produced if both add_prep and add_meas are true.\n\n\n\n\n\n","category":"type"},{"location":"public/#QuantumACES.RotatedPlanarCircuit","page":"Public API","title":"QuantumACES.RotatedPlanarCircuit","text":"RotatedPlanarCircuit\n\nSyndrome extraction circuit for a rotated surface code.\n\nFields\n\ncircuit_param::RotatedPlanarParameters: Circuit parameters.\ncircuit::Vector{Layer}: Circuit arranged by the tuple.\ncircuit_tuple::Vector{Int}: Tuple which arranges the order of the circuit layers; this is initialised as trivial.\nqubit_num::Int: Number of qubits in the circuit.\nunique_layer_indices::Vector{Int}: Unique layer indices of the circuit, which become meaningless and are removed the circuit is arranged by the tuple.\nlayer_types::Vector{Symbol}: Types of the layers in the circuit, used for layer times and dynamical decoupling.\nlayer_times::Vector{Float64}: Times taken to implement each layer in the circuit, as well as measurement and reset.\ngates::Vector{Gate}: Gates in the circuit arranged by the tuple.\ntotal_gates::Vector{Gate}: Gates in the original circuit, which includes noisy preparations if add_prep and noisy measurements if add_meas.\ngate_index::Dict{Gate, Int}: Index of the gate eigenvalues for each gates in the original circuit.\nN::Int: Number of gate eigenvalues.\nnoise_param::AbstractNoiseParameters: Noise parameters.\ngate_probabilities::Dict{Gate, Vector{Float64}}: Pauli error probabilities for each gate, stored as a dictionary.\ngate_eigenvalues::Vector{Float64}: Eigenvalues for each gate, stored as a vector whose order is determined by gate_index.\nadd_prep::Bool: Whether to treat preparations as noisy and characterise the associated noise, defaulting to false; a full-rank design cannot be produced if both add_prep and add_meas are true.\nadd_meas::Bool: Whether to treat measurements as noisy and characterise the associated noise, defaulting to true; a full-rank design cannot be produced if both add_prep and add_meas are true.\npartition::Tuple{Vector{Int}, Vector{Int}}: Partition of the qubits (data, ancilla), allowing for easy preparation of sign configurations for Pauli eigenstates.\nqubits::Vector{Tuple{Int, Int}}: Code qubit lattice locations.\ninverse_indices::Dict{Tuple{Int, Int}, Int}: Inverse mapping from the qubit lattice locations to their indices.\ndata_indices::Vector{Int}: Data qubit indices.\nancilla_indices::Vector{Int}: Ancilla qubit indices.\nancilla_X_indices::Vector{Int}: Ancilla X-check qubit indices.\nancilla_Z_indices::Vector{Int}: Ancilla Z-check qubit indices.\nqubit_layout::Matrix{String}: Diagram of the layout of the code qubits.\n\n\n\n\n\n","category":"type"},{"location":"public/#QuantumACES.RotatedPlanarParameters","page":"Public API","title":"QuantumACES.RotatedPlanarParameters","text":"RotatedPlanarParameters\n\nParameters for the syndrome extraction circuit of a rotated surface code.\n\nFields\n\nvertical_dist::Int: Vertical (Z) distance of the code.\nhorizontal_dist::Int: Horizontal (X) distance of the code.\ncheck_type::Symbol: Type of stabiliser used in the circuit, either :xzzx or :standard.\ngate_type::Symbol: Type of two-qubit gate used in the circuit, either :cx or :cz.\ndynamically_decouple::Bool: Whether to dynamically decouple the circuit; true is currently only supported for :xzzx and :cz.\npad_identity::Bool: Whether to pad layers with single-qubit identity gates.\nlayer_time_dict::Dict{Symbol, Float64}: Dictionary of layer times.\ncircuit_name::String: Name of the circuit used for saving data.\n\n\n\n\n\n","category":"type"},{"location":"public/#QuantumACES.UnrotatedPlanarCircuit","page":"Public API","title":"QuantumACES.UnrotatedPlanarCircuit","text":"UnrotatedPlanarCircuit\n\nSyndrome extraction circuit for a unrotated surface code.\n\nFields\n\ncircuit_param::UnrotatedPlanarParameters: Circuit parameters.\ncircuit::Vector{Layer}: Circuit arranged by the tuple.\ncircuit_tuple::Vector{Int}: Tuple which arranges the order of the circuit layers; this is initialised as trivial.\nqubit_num::Int: Number of qubits in the circuit.\nunique_layer_indices::Vector{Int}: Unique layer indices of the circuit, which become meaningless and are removed the circuit is arranged by the tuple.\nlayer_types::Vector{Symbol}: Types of the layers in the circuit, used for layer times and dynamical decoupling.\nlayer_times::Vector{Float64}: Times taken to implement each layer in the circuit, as well as measurement and reset.\ngates::Vector{Gate}: Gates in the circuit arranged by the tuple.\ntotal_gates::Vector{Gate}: Gates in the original circuit, which includes noisy preparations if add_prep and noisy measurements if add_meas.\ngate_index::Dict{Gate, Int}: Index of the gate eigenvalues for each gates in the original circuit.\nN::Int: Number of gate eigenvalues.\nnoise_param::AbstractNoiseParameters: Noise parameters.\ngate_probabilities::Dict{Gate, Vector{Float64}}: Pauli error probabilities for each gate, stored as a dictionary.\ngate_eigenvalues::Vector{Float64}: Eigenvalues for each gate, stored as a vector whose order is determined by gate_index.\nadd_prep::Bool: Whether to treat preparations as noisy and characterise the associated noise, defaulting to false; a full-rank design cannot be produced if both add_prep and add_meas are true.\nadd_meas::Bool: Whether to treat measurements as noisy and characterise the associated noise, defaulting to true; a full-rank design cannot be produced if both add_prep and add_meas are true.\npartition::Tuple{Vector{Int}, Vector{Int}}: Partition of the qubits (data, ancilla), allowing for easy preparation of sign configurations for Pauli eigenstates.\nqubits::Vector{Tuple{Int, Int}}: Code qubit lattice locations.\ninverse_indices::Dict{Tuple{Int, Int}, Int}: Inverse mapping from the qubit lattice locations to their indices.\ndata_indices::Vector{Int}: Data qubit indices.\nancilla_indices::Vector{Int}: Ancilla qubit indices.\nancilla_X_indices::Vector{Int}: Ancilla X-check qubit indices.\nancilla_Z_indices::Vector{Int}: Ancilla Z-check qubit indices.\nqubit_layout::Matrix{String}: Diagram of the layout of the code qubits.\n\n\n\n\n\n","category":"type"},{"location":"public/#QuantumACES.UnrotatedPlanarParameters","page":"Public API","title":"QuantumACES.UnrotatedPlanarParameters","text":"UnrotatedPlanarParameters\n\nParameters for the syndrome extraction circuit of an unrotated surface code.\n\nFields\n\nvertical_dist::Int: Vertical (Z) distance of the code.\nhorizontal_dist::Int: Horizontal (X) distance of the code.\ngate_type::Symbol: Type of two-qubit gate used in the circuit, which must be :cx.\npad_identity::Bool: Whether to pad layers with single-qubit identity gates.\nlayer_time_dict::Dict{Symbol, Float64}: Dictionary of layer times.\ncircuit_name::String: Name of the circuit used for saving data.\n\n\n\n\n\n","category":"type"},{"location":"public/#QuantumACES.get_circuit-Union{Tuple{T}, Tuple{RotatedPlanarParameters, T}} where T<:AbstractNoiseParameters","page":"Public API","title":"QuantumACES.get_circuit","text":"get_circuit(rotated_param::RotatedPlanarParameters, noise_param::AbstractNoiseParameters; kwargs...)\nget_circuit(unrotated_param::UnrotatedPlanarParameters, noise_param::AbstractNoiseParameters; kwargs...)\n\nReturns a circuit object, a subtype T <: AbstractCircuit, parameterised by the supplied circuit and noise parameters.\n\nArguments\n\nrotated_param::RotatedPlanarParameters: Parameters for a rotated surface code.\nunrotated_param::UnrotatedPlanarParameters: Parameters for an unrotated surface code.\nnoise_param::AbstractNoiseParameters: Noise parameters for the circuit.\n\nKeyword arguments\n\nadd_prep::Bool = false: Whether to treat preparations as noisy and characterise the associated noise, defaulting to false; a full-rank design cannot be produced if both add_prep and add_meas are true.\nadd_meas::Bool = true: Whether to treat measurements as noisy and characterise the associated noise, defaulting to true; a full-rank design cannot be produced if both add_prep and add_meas are true.\n\n\n\n\n\n","category":"method"},{"location":"public/#QuantumACES.get_layer_times-Tuple{Vector{Symbol}, Dict{Symbol, Float64}}","page":"Public API","title":"QuantumACES.get_layer_times","text":"get_layer_times(layer_types::Vector{Symbol}, layer_time_dict::Dict{Symbol, Float64})\n\nReturns the times taken to implement each layer in the circuit based on their types in layer_types and the times specified in `layertimedict, including the time for measurement and reset at the end.\n\n\n\n\n\n","category":"method"},{"location":"public/#QuantumACES.get_rotated_param-Tuple{Int64, Int64}","page":"Public API","title":"QuantumACES.get_rotated_param","text":"get_rotated_param(vertical_dist::Int, horizontal_dist::Int; kwargs...)\nget_rotated_param(dist::Int; kwargs...)\n\nReturns a RotatedPlanarParameters object that parameterises the syndrome extraction circuit of a rotated surface code.\n\nDefault gate layer times are estimated from Suppressing quantum errors by scaling a surface code logical qubit by Google Quantum AI (2023).\n\nArguments\n\nvertical_dist::Int: Vertical (Z) distance of the code.\nhorizontal_dist::Int: Horizontal (X) distance of the code.\ndist::Int: Distance of the code; this is equivalent to setting vertical_dist = dist and horizontal_dist = dist.\n\nKeyword arguments\n\ncheck_type::Symbol = :xzzx: Type of stabiliser used in the circuit, either :xzzx or :standard.\ngate_type::Symbol = :cz: Type of two-qubit gate used in the circuit, either :cx or :cz.\ndynamically_decouple::Bool = true: Whether to dynamically decouple the circuit; true is currently only supported for :xzzx and :cz.\npad_identity::Bool = true: Whether to pad layers with single-qubit identity gates.\nsingle_qubit_time::Float64 = 29.0: Time taken to implement a single-qubit gate in nanoseconds.\ntwo_qubit_time::Float64 = 29.0: Time taken to implement a two-qubit gate in nanoseconds.\nmeas_reset_time::Float64 = 660.0: Time taken to perform measurement and reset at the end of the circuit in nanoseconds.\ndynamical_decoupling_time::Float64 = 29.0: Time taken to implement a dynamical decoupling layer in nanoseconds.\n\n\n\n\n\n","category":"method"},{"location":"public/#QuantumACES.get_unrotated_param-Tuple{Int64, Int64}","page":"Public API","title":"QuantumACES.get_unrotated_param","text":"get_unrotated_param(vertical_dist::Int, horizontal_dist::Int; kwargs...)\nget_unrotated_param(dist::Int; kwargs...)\n\nReturns an UnrotatedPlanarParameters object that parameterises the syndrome extraction circuit of a unrotated surface code.\n\nDefault gate layer times are estimated from Suppressing quantum errors by scaling a surface code logical qubit by Google Quantum AI (2023).\n\nArguments\n\nvertical_dist::Int: Vertical (Z) distance of the code.\nhorizontal_dist::Int: Horizontal (X) distance of the code.\ndist::Int: Distance of the code; this is equivalent to setting vertical_dist = dist and horizontal_dist = dist.\n\nKeyword arguments\n\ngate_type::Symbol = :cx: Type of two-qubit gate used in the circuit, which must be :cx.\npad_identity::Bool = true: Whether to pad layers with single-qubit identity gates.\nsingle_qubit_time::Float64 = 29.0: Time taken to implement a single-qubit gate in nanoseconds.\ntwo_qubit_time::Float64 = 29.0: Time taken to implement a two-qubit gate in nanoseconds.\ndynamical_decoupling_time::Float64 = 29.0: Time taken to implement a dynamical decoupling layer in nanoseconds.\nmeas_reset_time::Float64 = 660.0: Time taken to perform measurement and reset at the end of the circuit in nanoseconds.\n\n\n\n\n\n","category":"method"},{"location":"public/#QuantumACES.prepare_circuit-Union{Tuple{T}, Tuple{Vector{Layer}, Int64, Vector{Symbol}, Vector{Float64}, T}} where T<:AbstractNoiseParameters","page":"Public API","title":"QuantumACES.prepare_circuit","text":"prepare_circuit(circuit::Vector{Layer}, qubit_num::Int, layer_types::Vector{Symbol}, layer_times::Vector{Float64}, noise_param::AbstractNoiseParameters; add_prep::Bool = false, add_meas::Bool = true)\n\nReturns a labelled copy of the circuit as well as a number of required fields for subtypes T <: AbstractCircuit.\n\nArguments\n\ncircuit::Vector{Layer}: Circuit.\nqubit_num::Int: Number of qubits in the circuit.\nlayer_types::Vector{Symbol}: Types of the layers in the circuit.\nlayer_times::Vector{Float64}: Times taken to implement each layer in the circuit, including measurement and reset at the end.\nnoise_param::AbstractNoiseParameters: Noise parameters.\n\nKeyword arguments\n\nadd_prep::Bool = false: Whether to treat preparations as noisy and aim to characterise them.\nadd_meas::Bool = true: Whether to treat measurements as noisy and aim to characterise them.\n\nReturns\n\ncircuit::Vector{Layer}: Circuit with labelled gates.\nunique_layer_indices::Vector{Int}: Indices of the unique layers in the circuit.\ngates::Vector{Gate}: Gates in the circuit.\ntotal_gates::Vector{Gate}: Total gates in the circuit, including preparations if add_prep and measurements if add_meas.\ngate_index::Dict{Gate, Int}: Index of the gate eigenvalues for each gate in the original circuit.\nN::Int: Number of gate eigenvalues.\ngate_probabilities::Dict{Gate, Vector{Float64}}: Pauli error probabilities for each gate, stored as a dictionary.\ngate_eigenvalues::Vector{Float64}: Eigenvalues for each gate, stored as a vector whose order is determined by gate_index.\n\n\n\n\n\n","category":"method"},{"location":"public/#QuantumACES.update_noise-Union{Tuple{U}, Tuple{T}, Tuple{T, U}} where {T<:AbstractCircuit, U<:AbstractNoiseParameters}","page":"Public API","title":"QuantumACES.update_noise","text":"update_noise(c::AbstractCircuit, noise_param::AbstractNoiseParameters)\n\nReturns a copy of c where the circuit has been updated with noise generated according to noise_param.\n\n\n\n\n\n","category":"method"},{"location":"public/#tuples.jl","page":"Public API","title":"tuples.jl","text":"","category":"section"},{"location":"public/","page":"Public API","title":"Public API","text":"Modules = [QuantumACES]\nPages = [\"tuples.jl\"]\nPrivate = false","category":"page"},{"location":"public/#QuantumACES.TupleSetData","page":"Public API","title":"QuantumACES.TupleSetData","text":"TupleSetData\n\nData parameterising a tuple set.\n\nFields\n\ntuple_set::Vector{Vector{Int}}: The main tuple set, whose tuples are not repeated.\nrepeat_tuple_set::Vector{Vector{Int}}: The repeated tuple set, whose tuples are repeated repeat_numbers times.\nrepeat_numbers::Vector{Int}: The number of repetitions for each tuple in the repeated tuple set repeat_tuple_set.\nrepeat_indices::Vector{Int}: Indexes the repetition number in repeat_numbers that describes the number of repetitions for each tuple in repeat_tuple_set.\n\n\n\n\n\n","category":"type"},{"location":"public/#QuantumACES.get_basic_tuple_set-Tuple{T} where T<:AbstractCircuit","page":"Public API","title":"QuantumACES.get_basic_tuple_set","text":"get_basic_tuple_set(c::AbstractCircuit)\n\nReturns the basic tuple set for the circuit c.\n\n\n\n\n\n","category":"method"},{"location":"public/#QuantumACES.get_tuple_set-Tuple{TupleSetData}","page":"Public API","title":"QuantumACES.get_tuple_set","text":"get_tuple_set(tuple_set_data::TupleSetData)\n\nReturns the tuple set corresponding to the data tuple_set_data.\n\n\n\n\n\n","category":"method"},{"location":"public/#QuantumACES.get_tuple_set_data-Union{Tuple{T}, Tuple{T, Vector{Vector{Int64}}}} where T<:AbstractCircuit","page":"Public API","title":"QuantumACES.get_tuple_set_data","text":"get_tuple_set_data(c::AbstractCircuit; init_scaling::Float64 = 0.2)\nget_tuple_set_data(c::AbstractCircuit, tuple_set::Vector{Vector{Int}}; init_scaling::Float64 = 0.2)\n\nReturns the tuple set data corresponding to the circuit c, with the non-repeated tuples either being the supplied tuple_set or the basic tuple set for c. The repeat numbers are initialised to be inversely proportional to the average noise on the gates in the layers, implicitly assuming depolarising noise, scaled by a factor init_scaling which is empirically helpful.\n\n\n\n\n\n","category":"method"},{"location":"public/#design.jl","page":"Public API","title":"design.jl","text":"","category":"section"},{"location":"public/","page":"Public API","title":"Public API","text":"Modules = [QuantumACES]\nPages = [\"design.jl\"]\nPrivate = false","category":"page"},{"location":"public/#QuantumACES.Design","page":"Public API","title":"QuantumACES.Design","text":"Design\n\nExperimental design for a noise characterisation experiment for a circuit.\n\nFields\n\nc::AbstractCircuit: Circuit characterised by the design.\nfull_covariance::Bool: If true, generates parameters to construct the full covariance matrix in covariance_dict_ensemble, else if false, only generates parameters to construct the terms on the diagonal.\nmatrix::SparseMatrixCSC{Int32, Int32}: Sparse M x N design matrix, corresponding to M circuit eigenvalues and N gate eigenvalues.\ntuple_set::Vector{Vector{Int}}: Set of tuples which arrange the circuit layers.\ntuple_set_data::TupleSetData: TupleSetData object that generates the tuple set.\nmapping_ensemble::Vector{Vector{Mapping}}: Vector of the Mapping objects for each of the circuit eigenvalue for the Paulis corresponding to that tuple, for each tuple in the set.\nexperiment_ensemble::Vector{Vector{Vector{Int}}}: Vector of the experiments that index Mapping objects, which correspond to simultaneously preparable and measurable circuit eigenvalues, for each tuple in the set.\ncovariance_dict_ensemble::Vector{Dict{CartesianIndex{2}, Tuple{Mapping, Int}}}: Dictionary of Mapping objects describing the non-zero entries of the sparse circuit eigenvalue estimator covariance matrix, alongside the number of times the entry is estimated by the experiment set, for each tuple in the set.\nprep_ensemble::Vector{Vector{Vector{Layer}}}: Vector of Layer objects that prepare qubits in Pauli eigenstates for each experiment in the set, indeed a vector preparing the necessary sign configurations, for each tuple in the set.\nmeas_ensemble::Vector{Vector{Layer}}: Vector of Layer objects that measure qubits in Pauli bases for each experiment in the set, for each tuple in the set.\ntuple_times::Vector{Float64}: Time taken to implement the circuit arranged by each tuple in the set, normalised according to the time factor for the basic tuple set.\nshot_weights::Vector{Float64}: Shot weights for each tuple in the set, which add to 1.\nexperiment_numbers::Vector{Int}: Number of experiments for each tuple in the set.\nexperiment_number::Int: Total number of experiments.\ncalculation_times::Matrix{Float64}: Time taken to generate components of the design for each tuple, which correspond to generating: the mappings, the sets of tuple-consistent Pauli preparations, the experiment sets, the covariance matrix dictionary, and the circuits.\noverall_time::Float64: Overall time taken to generate the design.\noptimisation_time::Float64: Time taken to optimise the design.\nls_type::Symbol: Type of least squares for which the shot weights were optimised.\n\n\n\n\n\n","category":"type"},{"location":"public/#QuantumACES.Mapping","page":"Public API","title":"QuantumACES.Mapping","text":"Mapping\n\nMapping of a Pauli operator by some circuit.\n\nFields\n\ninitial::Pauli: Initial Pauli operator before the action of the circuit.\nfinal::Pauli: Final Pauli operator after the action of the circuit.\ndesign_row::SparseVector{Int32, Int32}: Design matrix row for the circuit eigenvalue corresponding to the initial Pauli and the circuit used for the mapping.\nspread_track::Vector{Vector{Int16}}: Track of the support of the Pauli as it is acted upon by the layers of the circuit.\n\n\n\n\n\n","category":"type"},{"location":"public/#QuantumACES.Pauli","page":"Public API","title":"QuantumACES.Pauli","text":"Pauli\n\nBoolean representation of a Pauli operator.\n\nFields\n\npauli::Vector{Bool}: The Pauli operator stored as a Boolean vector. The first qubit_num elements represent Pauli X on each qubit, the next qubit_num elements represent Pauli Z on each qubit, and the final element represents the sign.\nqubit_num::Int16: The number of qubits on which the Pauli operator acts; the length of the vector is 2 * qubit_num + 1.\n\n\n\n\n\n","category":"type"},{"location":"public/#QuantumACES.complete_design-Tuple{Design}","page":"Public API","title":"QuantumACES.complete_design","text":"complete_design(d::Design; diagnostics::Bool = false)\n\nReturns a copy of the design d where the covariance matrix dictionary generates the full covariance matrix. Prints diagnostics if diagnostics is true.\n\n\n\n\n\n","category":"method"},{"location":"public/#QuantumACES.generate_design-Union{Tuple{T}, Tuple{T, Vector{Vector{Int64}}}} where T<:AbstractCircuit","page":"Public API","title":"QuantumACES.generate_design","text":"generate_design(c::AbstractCircuit, tuple_set::Vector{Vector{Int}}; kwargs...)\ngenerate_design(c::AbstractCircuit, tuple_set_data::TupleSetData; kwargs...)\ngenerate_design(c::AbstractCircuit; kwargs...)\n\nReturns a Design object containing all relevant information describing the experimental design, including the design matrix.\n\nArguments\n\nc::AbstractCircuit: Circuit for which the design matrix is to be generated.\ntuple_set::Vector{Vector{Int}}: Tuple set arranging the circuit layers that is used to generate the experimental design.\ntuple_set_data::TupleSetData: TupleSetData object that generates the tuple set.\n\nKeyword arguments\n\nshot_weights::Union{Vector{Float64}, Nothing} = nothing: Shot weights for each tuple in the set, which must add to 1. When nothing, automatically generates the default shot weights.\nfull_covariance::Bool = true: If true, generates parameters to construct the full covariance matrix, else if false, only generates parameters to construct the terms on the diagonal.\nN_warn::Int = 3 * 10^4: Number of circuit eigenvalues above which to warn the user about certain keyword argument choices.\ndiagnostics::Bool = false: Whether to print diagnostic information.\nsave_data::Bool = false: Whether to save the design data.\n\n\n\n\n\n","category":"method"},{"location":"public/#QuantumACES.update_noise-Union{Tuple{T}, Tuple{Design, T}} where T<:AbstractNoiseParameters","page":"Public API","title":"QuantumACES.update_noise","text":"update_noise(d::Design, noise_param::AbstractNoiseParameters)\n\nReturns a copy of design where the circuit has been updated with noise generated according to noise_param.\n\n\n\n\n\n","category":"method"},{"location":"public/#merit.jl","page":"Public API","title":"merit.jl","text":"","category":"section"},{"location":"public/","page":"Public API","title":"Public API","text":"Modules = [QuantumACES]\nPages = [\"merit.jl\"]\nPrivate = false","category":"page"},{"location":"public/#QuantumACES.Merit","page":"Public API","title":"QuantumACES.Merit","text":"Merit\n\nMerit parameters for an experimental design.\n\nFields\n\ncircuit_param::AbstractCircuitParameters: Circuit parameters.\nnoise_param::AbstractNoiseParameters: Noise parameters.\nls_type::Symbol: Type of least squares estimator for which the merit is reported.\ntuple_set::Vector{Vector{Int}}: Set of tuples which arrange the circuit layers.\ntuple_set_data::TupleSetData: TupleSetData object that generates the tuple set.\ntuple_times::Vector{Float64}: Time taken to implement the circuit corresponding to each tuple, normalised according to the basic tuple set.\nshot_weights::Vector{Float64}: Shot weights for each tuple in the set, which add to 1.\nexperiment_numbers::Vector{Int}: Number of experiments for each tuple in the set.\nexperiment_number::Int: Total number of experiments.\nG::Int: Total number of gates.\nN::Int: Number of gate eigenvalues.\nexpectation::Float64: Expected normalised RMS error for the gate eigenvalue estimator vector.\nvariance::Float64: Normalised RMS error variance for the gate eigenvalue estimator vector.\neigenvalues::Vector{Float64}: Eigenvalues of the gate eigenvalue estimator covariance matrix.\ncond_num::Float64: Condition number of the design matrix, the ratio of the largest and smallest singular values.\npinv_norm::Float64: Pseudoinverse norm of the design matrix, the inverse of the smallest singular value.\n\n\n\n\n\n","category":"type"},{"location":"public/#QuantumACES.calc_covariance_log-Tuple{Design}","page":"Public API","title":"QuantumACES.calc_covariance_log","text":"calc_covariance_log(d::Design; warning::Bool = true)\n\nReturns the covariance matrix of the circuit log-eigenvalues for the design d. If warning is true, warns that if d.full_covariance is false this will only generate the diagonal of the covariance matrix.\n\n\n\n\n\n","category":"method"},{"location":"public/#QuantumACES.calc_gls_merit-Tuple{Design}","page":"Public API","title":"QuantumACES.calc_gls_merit","text":"calc_gls_merit(d::Design)\n\nReturns the Merit object for the generalised least squares (GLS) estimator corresponding to the design d.\n\n\n\n\n\n","category":"method"},{"location":"public/#QuantumACES.calc_gls_moments-Tuple{Design, SparseArrays.SparseMatrixCSC{Float64, Int64}}","page":"Public API","title":"QuantumACES.calc_gls_moments","text":"calc_gls_moments(d::Design, covariance_log::SparseMatrixCSC{Float64, Int})\n\nReturns the expectation and variance of the normalised RMS error for the generalised least squares (GLS) estimator corresponding to the design d with circuit log-eigenvalue estimator covariance matrix covariance_log.\n\n\n\n\n\n","category":"method"},{"location":"public/#QuantumACES.calc_ls_merit-Tuple{Design, Symbol}","page":"Public API","title":"QuantumACES.calc_ls_merit","text":"calc_ls_merit(d::Design, ls_type::Symbol)\n\nReturns the Merit object for the least squares estimator specified by ls_type (:gls, :wls, or :ols) corresponding to the design d.\n\n\n\n\n\n","category":"method"},{"location":"public/#QuantumACES.calc_ls_moments-Tuple{Design, SparseArrays.SparseMatrixCSC{Float64, Int64}, Symbol}","page":"Public API","title":"QuantumACES.calc_ls_moments","text":"calc_ls_moments(d::Design, covariance_log::SparseMatrixCSC{Float64, Int}, ls_type::Symbol)\n\nReturns the expectation and variance of the normalised RMS error for the least squares estimator specified by ls_type (:gls, :wls, or :ols) corresponding to the design d with circuit log-eigenvalue estimator covariance matrix covariance_log.\n\n\n\n\n\n","category":"method"},{"location":"public/#QuantumACES.calc_merit_set-Tuple{Design}","page":"Public API","title":"QuantumACES.calc_merit_set","text":"calc_ls_merit(d::Design, ls_type::Symbol)\n\nReturns Merit objects for all three least squares estimators (generalised, weighted, and ordinary least squares) corresponding to the design d.\n\n\n\n\n\n","category":"method"},{"location":"public/#QuantumACES.calc_ols_merit-Tuple{Design}","page":"Public API","title":"QuantumACES.calc_ols_merit","text":"calc_ols_merit(d::Design)\n\nReturns the Merit object for the ordinary least squares (OLS) estimator corresponding to the design d.\n\n\n\n\n\n","category":"method"},{"location":"public/#QuantumACES.calc_ols_moments-Tuple{Design, SparseArrays.SparseMatrixCSC{Float64, Int64}}","page":"Public API","title":"QuantumACES.calc_ols_moments","text":"calc_ols_moments(d::Design, covariance_log::SparseMatrixCSC{Float64, Int})\n\nReturns the expectation and variance of the normalised RMS error for the ordinary least squares (OLS) estimator corresponding to the design d with circuit log-eigenvalue estimator covariance matrix covariance_log.\n\n\n\n\n\n","category":"method"},{"location":"public/#QuantumACES.calc_wls_merit-Tuple{Design}","page":"Public API","title":"QuantumACES.calc_wls_merit","text":"calc_wls_merit(d::Design)\n\nReturns the Merit object for the weighted least squares (WLS) estimator corresponding to the design d.\n\n\n\n\n\n","category":"method"},{"location":"public/#QuantumACES.calc_wls_moments-Tuple{Design, SparseArrays.SparseMatrixCSC{Float64, Int64}}","page":"Public API","title":"QuantumACES.calc_wls_moments","text":"calc_wls_moments(d::Design, covariance_log::SparseMatrixCSC{Float64, Int})\n\nReturns the expectation and variance of the normalised RMS error for the weighted least squares (WLS) estimator corresponding to the design d with circuit log-eigenvalue estimator covariance matrix covariance_log.\n\n\n\n\n\n","category":"method"},{"location":"public/#QuantumACES.nrmse_pdf-Tuple{Vector{Float64}, Vector{Float64}}","page":"Public API","title":"QuantumACES.nrmse_pdf","text":"nrmse_pdf(cov_eigenvalues::Vector{Float64}, nrmse_values::Vector{Float64}; epsilon::Float64 = 1e-5)\n\nReturns the probability density function (PDF) for the normalised RMS error (NRMSE) of the gate eigenvalue estimator vector, which follows a generalised chi-squared distribution and whose covariance matrix has eigenvalues cov_eigenvalues, at the coordinates specified by nrmse_values. Does not calculate values when the normal approximation to the PDF is less than a factor of epsilon of its maximum value.\n\nCalculation follows Eq. 3.2 of Computing the distribution of quadratic forms in normal variables by J. P. Imhof (1961).\n\n\n\n\n\n","category":"method"},{"location":"public/#weights.jl","page":"Public API","title":"weights.jl","text":"","category":"section"},{"location":"public/","page":"Public API","title":"Public API","text":"Modules = [QuantumACES]\nPages = [\"weights.jl\"]\nPrivate = false","category":"page"},{"location":"public/#QuantumACES.compare_ls_optimise_weights-Tuple{Design, SparseArrays.SparseMatrixCSC{Float64, Int64}}","page":"Public API","title":"QuantumACES.compare_ls_optimise_weights","text":"compare_ls_optimise_weights(d::Design, covariance_log::SparseMatrixCSC{Float64, Int}; gls_options::OptimOptions = OptimOptions(; ls_type = :gls), wls_options::OptimOptions = OptimOptions(; ls_type = :wls), ols_options::OptimOptions = OptimOptions(; ls_type = :ols))\n\nReturns versions of the design d and circuit log-eigenvalue estimator covariance matrix covariance_log after optimising the shot weights with respect to the figure of merit, alongside the figure of merit values at each step and the final merits, for all three least squares estimator types. The optimisation for each is parameterised by the OptimOptions objects gls_options, wls_options, and ols_options, respectively.\n\n\n\n\n\n","category":"method"},{"location":"public/#QuantumACES.gls_optimise_weights-Tuple{Design, SparseArrays.SparseMatrixCSC{Float64, Int64}}","page":"Public API","title":"QuantumACES.gls_optimise_weights","text":"gls_optimise_weights(d::Design, covariance_log::SparseMatrixCSC{Float64, Int}; options::OptimOptions = OptimOptions())\n\nReturns versions of the design d and circuit log-eigenvalue estimator covariance matrix covariance_log after optimising the shot weights with respect to the generalised least squares (GLS) figure of merit, alongside the figure of merit values at each step. The optimisation is parameterised by the OptimOptions object options.\n\n\n\n\n\n","category":"method"},{"location":"public/#QuantumACES.ols_optimise_weights-Tuple{Design, SparseArrays.SparseMatrixCSC{Float64, Int64}}","page":"Public API","title":"QuantumACES.ols_optimise_weights","text":"ols_optimise_weights(d::Design, covariance_log::SparseMatrixCSC{Float64, Int}; options::OptimOptions = OptimOptions())\n\nReturns versions of the design d and circuit log-eigenvalue estimator covariance matrix covariance_log after optimising the shot weights with respect to the ordinary least squares (OLS) figure of merit, alongside the figure of merit values at each step. The optimisation is parameterised by the OptimOptions object options.\n\n\n\n\n\n","category":"method"},{"location":"public/#QuantumACES.optimise_weights-Tuple{Design, SparseArrays.SparseMatrixCSC{Float64, Int64}}","page":"Public API","title":"QuantumACES.optimise_weights","text":"optimise_weights(d::Design, covariance_log::SparseMatrixCSC{Float64, Int}; options::OptimOptions = OptimOptions())\n\nReturns versions of the design d and circuit log-eigenvalue estimator covariance matrix covariance_log after optimising the shot weights with respect to the figure of merit, alongside the figure of merit values at each step. The optimisation is parameterised by the OptimOptions object options, which in particular specifies the least squares estimator type for which the figure of merit is calculated.\n\n\n\n\n\n","category":"method"},{"location":"public/#QuantumACES.wls_optimise_weights-Tuple{Design, SparseArrays.SparseMatrixCSC{Float64, Int64}}","page":"Public API","title":"QuantumACES.wls_optimise_weights","text":"wls_optimise_weights(d::Design, covariance_log::SparseMatrixCSC{Float64, Int}; options::OptimOptions = OptimOptions())\n\nReturns versions of the design d and circuit log-eigenvalue estimator covariance matrix covariance_log after optimising the shot weights with respect to the weighted least squares (WLS) figure of merit, alongside the figure of merit values at each step. The optimisation is parameterised by the OptimOptions object options.\n\n\n\n\n\n","category":"method"},{"location":"public/#optimise.jl","page":"Public API","title":"optimise.jl","text":"","category":"section"},{"location":"public/","page":"Public API","title":"Public API","text":"Modules = [QuantumACES]\nPages = [\"optimise.jl\"]\nPrivate = false","category":"page"},{"location":"public/#QuantumACES.optimise_design-Union{Tuple{T}, Tuple{T, TupleSetData}} where T<:AbstractCircuit","page":"Public API","title":"QuantumACES.optimise_design","text":"optimise_design(c::AbstractCircuit; options::OptimOptions = OptimOptions())\noptimise_design(c::AbstractCircuit, tuple_set_data::TupleSetData; options::OptimOptions = OptimOptions())\n\nReturns an optimised experimental design for the circuit c initialised with the tuple set data tuple_set_data. The optimisation is parameterised by the OptimOptions object options.\n\n\n\n\n\n","category":"method"},{"location":"public/#QuantumACES.optimise_repetitions-Union{Tuple{T}, Tuple{T, TupleSetData}} where T<:AbstractCircuit","page":"Public API","title":"QuantumACES.optimise_repetitions","text":"optimise_repetitions(c::AbstractCircuit, tuple_set_data::TupleSetData; options::OptimOptions = OptimOptions())\n\nReturns the tuple set data after optimising the repetition numbers in the supplied tuple set data tuple_set_data for the circuit c. The optimisation is parameterised by the OptimOptions object options.\n\n\n\n\n\n","category":"method"},{"location":"public/#QuantumACES.optimise_tuple_set-Tuple{Design, SparseArrays.SparseMatrixCSC{Float64, Int64}}","page":"Public API","title":"QuantumACES.optimise_tuple_set","text":"optimise_tuple_set(d::Design, covariance_log::SparseMatrixCSC{Float64, Int}; options::OptimOptions = OptimOptions())\n\nReturns versions of the design d and circuit log-eigenvalue estimator covariance matrix covariance_log after optimising the tuple set of the design with repeated excursions that grow and prune the tuple set. The optimisation is parameterised by the OptimOptions object options.\n\n\n\n\n\n","category":"method"},{"location":"public/#scaling.jl","page":"Public API","title":"scaling.jl","text":"","category":"section"},{"location":"public/","page":"Public API","title":"Public API","text":"Modules = [QuantumACES]\nPages = [\"scaling.jl\"]\nPrivate = false","category":"page"},{"location":"public/#QuantumACES.DepolarisingPlanarScaling","page":"Public API","title":"QuantumACES.DepolarisingPlanarScaling","text":"DepolarisingPlanarScaling\n\nScaling data for an experimental design for the syndrome extraction circuit of a surface code with depolarising Pauli noise.\n\nFields\n\ndist_range::Vector{Int}: Code distances.\nmerit_scaling::Vector{Merit}: Merit of the design for a range of code distances.\nG_fit::Function: Gate number fit.\nG_params::Vector{Int}: Gate number fit parameters; a + bd + cd^2.\nN_fit::Function: Gate eigenvalue number fit.\nN_params::Vector{Int}: Gate eigenvalue number fit parameters; a + bd + cd^2.\ntrace_fit::Function: Trace of the gate eigenvalue estimator covariance matrix fit.\ntrace_params::Vector{Float64}: Trace of the gate eigenvalue estimator covariance matrix fit parameters; a + bd + cd^2.\ntrace_sq_fit::Function: Trace of the gate eigenvalue estimator covariance matrix squared fit.\ntrace_sq_params::Vector{Float64}: Trace of the gate eigenvalue estimator covariance matrix squared fit parameters; a + bd + cd^2.\nexpectation_fit::Function: Normalised RMS error expectation fit.\nvariance_fit::Function: Normalised RMS error variance fit.\ncircuit_param::AbstractCircuitParameters: Code parameters.\nnoise_param::DepolarisingParameters: Depolarising noise parameters.\ntuple_set::Vector{Vector{Int}}: Set of tuples which arrange the circuit layers.\ntuple_set_data::TupleSetData: TupleSetData object that generates the tuple set.\nshot_weights::Vector{Float64}: Shot weights for each tuple in the set, which add to 1.\nls_type::Symbol: Type of least squares estimator for which the merits were calculated.\ncalculation_times::Matrix{Float64}: Time taken to generate the design and calculate the merit, respectively, for each distance.\noverall_time::Float64: The overall time taken to calculate the merit scaling data for depolarising noise.\n\n\n\n\n\n","category":"type"},{"location":"public/#QuantumACES.LognormalPlanarScaling","page":"Public API","title":"QuantumACES.LognormalPlanarScaling","text":"LognormalPlanarScaling\n\nScaling data for an experimental design for the syndrome extraction circuit of a surface code with log-normal random Pauli noise.\n\nFields\n\ndist_range::Vector{Int}: Code distances.\nN_fit::Function: Gate eigenvalue number fit.\nN_params::Vector{Int}: Gate eigenvalue number fit parameters; a + bd + cd^2.\nexpectation_scaling::Vector{Vector{Float64}}: Expected normalised RMS error for a range of code distances.\nexpectation_fit::Function: Mean expected normalised RMS error fit.\nvariance_scaling::Vector{Vector{Float64}}: Normalised RMS error variance for a range of code distances.\nvariance_fit::Function: Mean normalised RMS error variance fit.\neigenvalues_scaling::Vector{Vector{Vector{Float64}}}: Eigenvalues of the gate log-eigenvalue estimator covariance matrix for a range of code distances.\ncircuit_param::AbstractCircuitParameters: Code parameters.\nnoise_param::LognormalParameters: Log-normal random noise parameters.\nseeds::Vector{UInt64}: Seeds for the log-normal noise parameters.\ntuple_set::Vector{Vector{Int}}: Set of tuples which arrange the circuit layers.\ntuple_set_data::TupleSetData: TupleSetData object that generates the tuple set.\nshot_weights::Vector{Float64}: Shot weights for each tuple in the set, which add to 1.\nls_type::Symbol: Type of least squares estimator for which the merits were calculated.\ncalculation_times::Matrix{Float64}: The time taken to generate the design and calculate the figures of merit for random instances of log-normal Pauli noise, and for depolarising Pauli noise, respectively.\noverall_time::Float64: The overall time taken to calculate the merit scaling for log-normal random noise.\n\n\n\n\n\n","category":"type"},{"location":"public/#QuantumACES.calc_depolarising_planar_scaling-Tuple{Design, Vector{Int64}}","page":"Public API","title":"QuantumACES.calc_depolarising_planar_scaling","text":"calc_depolarising_planar_scaling(d::Design, dist_max::Int; kwargs...)\ncalc_depolarising_planar_scaling(d::Design, dist_range::Vector{Int}; kwargs...)\n\nReturns the scaling data as a DepolarisingPlanarScaling object for the figure of merit of the design d for the syndrome extraction circuit of a surface code with depolarising Pauli noise, as a function of the distance of the code.\n\nArguments\n\nd::Design: Design for which the merit scaling is calculated.\ndist_max::Int: Maximum code distance for which the merit scaling is calculated.\ndist_range::Vector{Int}: Vode distances for which the merit scaling is calculated.\n\nKeyword arguments\n\nls_type::Symbol = :none: Type of least squares estimator used to calculate the merit scaling, which defaults to the least squares estimator type of the design, or if that is not specified, :wls.\ndiagnostics::Bool = true: Whether to print diagnostic information.\nsave_data::Bool = false: Whether to save the merit scaling data.\n\n\n\n\n\n","category":"method"},{"location":"public/#QuantumACES.calc_lognormal_planar_scaling-Tuple{Design, Vector{Int64}}","page":"Public API","title":"QuantumACES.calc_lognormal_planar_scaling","text":"calc_lognormal_planar_scaling(d::Design, dist_max::Int; kwargs...)\ncalc_lognormal_planar_scaling(d::Design, dist_range::Vector{Int}; kwargs...)\n\nReturns the scaling data as a LognormalPlanarScaling object for the figure of merit of the design d for the syndrome extraction circuit of a surface code with log-normal random Pauli noise, as a function of the distance of the code.\n\nArguments\n\nd::Design: Design for which the merit scaling is calculated.\ndist_max::Int: Maximum code distance for which the merit scaling is calculated.\ndist_range::Vector{Int}: Code distances for which the merit scaling is calculated.\n\nKeyword arguments\n\nls_type::Symbol = :none: Type of least squares estimator used to calculate the merit scaling, which defaults to the least squares estimator type of the design, or if that is not specified, :wls.\nprecision::Float64 = 1e-3: Precision to which the figure of merit is estimated, corresponding to the target standard error of the mean.\nmax_repetitions::Int = 10000: Maximum number of random instances of log-normal Pauli noise over which the figure of merit is calculated.\nmin_repetitions::Int = 100: Minimum number of random instances of log-normal Pauli noise over which the figure of merit is calculated.\nprint_repetitions::Int = 100: Number of random instances of log-normal Pauli noise between printing diagnostics.\nseed::Union{UInt64, Nothing} = nothing: Seeds used to generate instances of log-normal Pauli noise.\ndiagnostics::Bool = true: Whether to print diagnostic information.\nsave_data::Bool = false: Whether to save the merit scaling data.\n\n\n\n\n\n","category":"method"},{"location":"public/#simulate.jl","page":"Public API","title":"simulate.jl","text":"","category":"section"},{"location":"public/","page":"Public API","title":"Public API","text":"Modules = [QuantumACES]\nPages = [\"simulate.jl\"]\nPrivate = false","category":"page"},{"location":"public/#QuantumACES.ACESData","page":"Public API","title":"QuantumACES.ACESData","text":"ACESData\n\nACES noise characterisation experiment simulation results.\n\nFields\n\nd::Design: Experimental design.\nbudget_set::Vector{Int}: Measurement budgets.\nshots_set::Vector{Int}: Measurement shots corresponding to the measurement budgets in budget_set.\nrepetitions::Int: Number of times to repeat the ACES estimation procedure.\nseeds::Vector{UInt64}: Seeds for each of the repetitions.\neigenvalues::Vector{Float64}: Circuit eigenvalues.\ncovariance::SparseMatrixCSC{Float64, Int32}: Circuit eigenvalue estimator covariance matrix.\nest_eigenvalues_coll::Matrix{Vector{Float64}}: Estimated circuit eigenvalues for each of the measurement budgets and repetitions.\nfgls_gate_eigenvalues_coll::Matrix{Vector{Float64}}: FGLS estimated gate eigenvalues for each of the measurement budgets and repetitions.\ngls_gate_eigenvalues_coll::Matrix{Vector{Float64}}: GLS estimated gate eigenvalues for each of the measurement budgets and repetitions, which uses the true circuit eigenvalue estimator covariance matrix.\nwls_gate_eigenvalues_coll::Matrix{Vector{Float64}}: WLS estimated gate eigenvalues for each of the measurement budgets and repetitions.\nols_gate_eigenvalues_coll::Matrix{Vector{Float64}}: OLS estimated gate eigenvalues for each of the measurement budgets and repetitions.\nfgls_gate_probabilities_coll::Matrix{Dict{Gate, Vector{Float64}}}: FGLS estimated gate probability distributions for each of the measurement budgets and repetitions.\ngls_gate_probabilities_coll::Matrix{Dict{Gate, Vector{Float64}}}: GLS estimated gate probability distributions for each of the measurement budgets and repetitions.\nwls_gate_probabilities_coll::Matrix{Dict{Gate, Vector{Float64}}}: WLS estimated gate probability distributions for each of the measurement budgets and repetitions.\nols_gate_probabilities_coll::Matrix{Dict{Gate, Vector{Float64}}}: OLS estimated gate probability distributions for each of the measurement budgets and repetitions.\nfgls_gate_norm_coll::Matrix{Float64}: Normalised RMS error between the FGLS estimated gate eigenvalues and the true gate eigenvalues for each of the measurement budgets and repetitions.\ngls_gate_norm_coll::Matrix{Float64}: Normalised RMS error between the GLS estimated gate eigenvalues and the true gate eigenvalues for each of the measurement budgets and repetitions.\nwls_gate_norm_coll::Matrix{Float64}: Normalised RMS error between the WLS estimated gate eigenvalues and the true gate eigenvalues for each of the measurement budgets and repetitions.\nols_gate_norm_coll::Matrix{Float64}: Normalised RMS error between the OLS estimated gate eigenvalues and the true gate eigenvalues for each of the measurement budgets and repetitions.\ncalculation_times::Matrix{Float64}: Time taken to simulate sampling and estimate the gate eigenvalues with FGLS, GLS, WLS, and OLS for each repetition.\noverall_time::Float64: Overall time taken to simulate ACES across all repetitions.\n\n\n\n\n\n","category":"type"},{"location":"public/#QuantumACES.simulate_aces-Tuple{Design, Vector{Int64}}","page":"Public API","title":"QuantumACES.simulate_aces","text":"simulate_aces(d::Design, budget_set::Vector{Int}; kwargs...)\n\nSimulates ACES noise characterisation experiments for the experimental design d across each of the measurement budgets in budget_set.\n\nWARNING: Seeding has the same features as in Stim. The behaviour of the same random seed will differ across different versions of Stim. Also, when measurement shots are sampled in batches, which occurs when max_samples is exceeded, the results will differ from when all shots are sampled at once.\n\nArguments\n\nd::Design: Experimental design.\nbudget_set::Vector{Int}: Measurement budgets for which to simulate ACES.\n\nKeyword arguments\n\nrepetitions::Int = 1: Number of simulation repetitions.\nseed::Union{UInt64, Nothing} = nothing: the seed to use for the random number generator.\nN_warn::Int = 3 * 10^4: Number of circuit eigenvalues above which to warn the user about certain keyword argument choices.\nmax_samples::Int = 10^10: Maximum number of Stim samples collected in a single simulation.\nforce_gc::Bool = false: Whether to force garbage collection before and after each Stim simulation; this was added to prevent occasional segfaults but massively slows down the simulation, and currently does not appear to be necessary.\ndiagnostics::Bool = true: Whether to print diagnostics.\ndetailed_diagnostics::Bool = false: Whether to print detailed diagnostics.\nsave_data::Bool = false: Whether to save the data.\nsave_interval::Int = 50: Repetition interval at which to save the data.\nclear_design::Bool = false: Whether to clear the saved design data after saving the full simulation data.\n\n\n\n\n\n","category":"method"},{"location":"public/#kwargs.jl","page":"Public API","title":"kwargs.jl","text":"","category":"section"},{"location":"public/","page":"Public API","title":"Public API","text":"Modules = [QuantumACES]\nPages = [\"kwargs.jl\"]\nPrivate = false","category":"page"},{"location":"public/#QuantumACES.OptimOptions","page":"Public API","title":"QuantumACES.OptimOptions","text":"OptimOptions\n\nKeyword arguments for optimise_design, and specifically the optimisation functions within it, including for the gradient descent function optimise_weights, the repetition number optimisation function optimise_repetitions, and the tuple set optimisation function optimise_tuple_set.\n\nGeneral options\n\nls_type::Symbol = :wls: The type of least squares estimator for which we optimise the design, which can be :gls, :wls, or :ols.\nsave_data::Bool = false: Whether to automatically save the optimised design.\n\nGradient descent options\n\nlearning_rate::Float64 = (ls_type == :ols ? 1.0 : 10.0^(3/4)): Learning rate for the gradient descent algorithm.\nmomentum::Float64 = 0.99: Momentum for the gradient descent algorithm.\nlearning_rate_scale_factor::Float64 = 10.0^(1/4): Factor by which to reduce the learning rate if the gradient descent algorithm repeatedly steps in directions that reduce the figure of merit.\nshot_weights_clip::Float64 = 1e-5: If any tuple has shot weight below this threshold, the algorithm greedily considers pruning it from the tuple set.\nmax_steps::Int = 400: Maximum number of gradient descent steps to take.\nconvergence_threshold::Float64 = 1e-5: Convergence threshold for the gradient descent algorithm.\nconvergence_steps::Int = 5: Number of steps over which to check convergence.\ngrad_diagnostics::Bool = false: Whether to display gradient descent diagnostics.\n\nReptition number optimisation options\n\nmax_cycles::Int = 50: Maximum number of cycles to use in the cyclic coordinate descent algorithm for optimising repetition numbers.\nrep_diagnostics::Bool = true: Whether to display repetition number optimisation diagnostics.\n\nTuple set optimisation options\n\nexcursion_number::Int = 5: Number of excurisons used to optimise the tuple set.\nexcursion_length::Int = 5: Number of tuples added by each excursion past the max_tuple_number, so that at the end of an excursion the tuple set will have up to max_tuple_number + excursion_length tuples.\nmax_tuple_number::Int = 35: Maximum number of tuples in the optimised tuple set.\nmax_tuple_length::Int = 20: Maximum length of random tuples.\ntuple_length_zipf_power::Float64 = 1.0: Zipf power to use when Zipf-randomly choosing the length of random tuples.\nrepeat_zipf_powers::Vector{Float64} = [Inf; 2.0]: Zipf power to use, chosen uniformly at random from the vector, when Zipf-randomly choosing how many times to repeat entries that will be appended to the end of a random tuple during its generation.\nmirror_values::Vector{Bool} = [false; true]: Whether to mirror the tuple, chosen uniformly at random from the vector, when generating random tuples.\ntrial_factor::Int = 20: Number of random tuples trialled for each tuple the excursion needs to add to the tuple set to grow it to the max_tuple_number.\ngrow_greedy::Bool = true: Whether the excursions add tuples to the set greedily according to the figure of merit, or to add them even if this reduces the figure of merit.\nseed::Union{UInt64, Nothing} = nothing: Seed used to randomly generate tuples.\ntuple_diagnostics::Bool = true: Whether to display tuple set optimisation diagnostics.\n\n\n\n\n\n","category":"type"},{"location":"public/#utils.jl","page":"Public API","title":"utils.jl","text":"","category":"section"},{"location":"public/","page":"Public API","title":"Public API","text":"Modules = [QuantumACES]\nPages = [\"utils.jl\"]\nPrivate = false","category":"page"},{"location":"public/#QuantumACES.get_mapping_string-Union{Tuple{T}, Tuple{Mapping, T}} where T<:AbstractCircuit","page":"Public API","title":"QuantumACES.get_mapping_string","text":"get_mapping_string(m::Mapping, c::AbstractCircuit; two_qubit_only::Bool = false)\n\nReturns the string representation of the mapping m for the circuit c, including eigenvalues.\n\n\n\n\n\n","category":"method"},{"location":"public/#QuantumACES.get_pauli_string-Tuple{Pauli}","page":"Public API","title":"QuantumACES.get_pauli_string","text":"get_pauli_string(p::Pauli)\n\nReturns the string representation of the Pauli p.\n\n\n\n\n\n","category":"method"},{"location":"public/#QuantumACES.get_support-Tuple{Pauli}","page":"Public API","title":"QuantumACES.get_support","text":"get_support(p::Pauli)\n\nReturns the support of the Pauli p.\n\n\n\n\n\n","category":"method"},{"location":"public/#QuantumACES.pretty_print-Tuple{ACESData, Tuple{Merit, Merit, Merit}}","page":"Public API","title":"QuantumACES.pretty_print","text":"pretty_print(aces_data::ACESData, merit_set::Tuple{Merit, Merit, Merit})\n\nPrints the z-scores of the normalised RMS errors of the gate eigenvalue estimator vector for the GLS, WLS, and OLS estimators in aces_data using the predicted means and variances for each in merit_set.\n\n\n\n\n\n","category":"method"},{"location":"public/#QuantumACES.pretty_print-Tuple{Design}","page":"Public API","title":"QuantumACES.pretty_print","text":"pretty_print(d::Design)\n\nPrints the tuple set and shot weight data of the design d in a readable format.\n\n\n\n\n\n","category":"method"},{"location":"public/#QuantumACES.pretty_print-Tuple{Matrix{Float64}}","page":"Public API","title":"QuantumACES.pretty_print","text":"pretty_print(merit_array::Matrix{Float64})\n\nPrints merit_array, produced by compare_ls_optimise_weights, in a readable format.\n\n\n\n\n\n","category":"method"},{"location":"public/#io.jl","page":"Public API","title":"io.jl","text":"","category":"section"},{"location":"public/","page":"Public API","title":"Public API","text":"Modules = [QuantumACES]\nPages = [\"io.jl\"]\nPrivate = false","category":"page"},{"location":"public/#QuantumACES.aces_data_filename-Union{Tuple{U}, Tuple{T}, Tuple{T, U, Int64, Vector{Int64}, Bool, Symbol, Vector{Int64}}} where {T<:AbstractCircuitParameters, U<:AbstractNoiseParameters}","page":"Public API","title":"QuantumACES.aces_data_filename","text":"aces_data_filename(aces_data::ACESData)\naces_data_filename(d::Design, budget_set::Vector{Int})\naces_data_filename(circuit_param::AbstractCircuitParameters, noise_param::AbstractNoiseParameters, tuple_number::Int, repeat_numbers::Vector{Int}, full_covariance::Bool, ls_type::Symbol, budget_set::Vector{Int})\n\nReturns a string describing the filename corresponding to the ACES data.\n\n\n\n\n\n","category":"method"},{"location":"public/#QuantumACES.delete_aces-Tuple{ACESData}","page":"Public API","title":"QuantumACES.delete_aces","text":"delete_aces(aces_data::ACESData)\n\nDeletes the file corresponding to the ACES data aces_data.\n\n\n\n\n\n","category":"method"},{"location":"public/#QuantumACES.delete_design-Tuple{Design}","page":"Public API","title":"QuantumACES.delete_design","text":"delete_design(d::Design)\n\nDeletes the file corresponding to the design d.\n\n\n\n\n\n","category":"method"},{"location":"public/#QuantumACES.delete_scaling-Tuple{T} where T<:AbstractScalingData","page":"Public API","title":"QuantumACES.delete_scaling","text":"delete_scaling(scaling_data::AbstractScalingData)\n\nDeletes the file corresponding to the scaling data scaling_data.\n\n\n\n\n\n","category":"method"},{"location":"public/#QuantumACES.design_filename-Union{Tuple{U}, Tuple{T}, Tuple{T, U, Int64, Vector{Int64}, Bool, Symbol}} where {T<:AbstractCircuitParameters, U<:AbstractNoiseParameters}","page":"Public API","title":"QuantumACES.design_filename","text":"design_filename(d::Design)\ndesign_filename(circuit_param::AbstractCircuitParameters, noise_param::AbstractNoiseParameters, tuple_number::Int, repeat_numbers::Vector{Int}, full_covariance::Bool, ls_type::Symbol)\n\nReturns a string describing the filename corresponding to the supplied design data.\n\n\n\n\n\n","category":"method"},{"location":"public/#QuantumACES.enter_folder-Tuple{String}","page":"Public API","title":"QuantumACES.enter_folder","text":"enter_folder(folder::String)\n\nIf not currently in the folder folder, enter it.\n\n\n\n\n\n","category":"method"},{"location":"public/#QuantumACES.exit_folder-Tuple{String}","page":"Public API","title":"QuantumACES.exit_folder","text":"exit_folder(folder::String)\n\nIf currently in the folder folder, exit it.\n\n\n\n\n\n","category":"method"},{"location":"public/#QuantumACES.load_aces-Union{Tuple{U}, Tuple{T}, Tuple{T, U, Int64, Vector{Int64}, Bool, Symbol, Vector{Int64}}} where {T<:AbstractCircuitParameters, U<:AbstractNoiseParameters}","page":"Public API","title":"QuantumACES.load_aces","text":"load_aces(d::Design, budget_set::Vector{Int})\nload_aces(circuit_param::AbstractCircuitParameters, noise_param::AbstractNoiseParameters, tuple_number::Int, repeat_numbers::Vector{Int}, full_covariance::Bool, ls_type::Symbol, budget_set::Vector{Int})\n\nLoads the ACES data whose filename is specified by the supplied variables.\n\n\n\n\n\n","category":"method"},{"location":"public/#QuantumACES.load_design-Union{Tuple{U}, Tuple{T}, Tuple{T, U, Int64, Vector{Int64}, Bool, Symbol}} where {T<:AbstractCircuitParameters, U<:AbstractNoiseParameters}","page":"Public API","title":"QuantumACES.load_design","text":"load_design(circuit_param::AbstractCircuitParameters, noise_param::AbstractNoiseParameters, tuple_number::Int, repeat_numbers::Vector{Int}, full_covariance::Bool, ls_type::Symbol)\n\nLoads the design whose filename is specified by the supplied variables.\n\n\n\n\n\n","category":"method"},{"location":"public/#QuantumACES.load_scaling-Union{Tuple{U}, Tuple{T}, Tuple{T, U, Int64, Vector{Int64}, Symbol}} where {T<:AbstractCircuitParameters, U<:AbstractNoiseParameters}","page":"Public API","title":"QuantumACES.load_scaling","text":"load_scaling(d::Design, ls_type::Symbol)\nload_scaling(circuit_param::AbstractCircuitParameters, noise_param::AbstractNoiseParameters, tuple_number::Int, repeat_numbers::Vector{Int}, ls_type::Symbol)\n\nLoads the scaling data whose filename is specified by the supplied variables.\n\n\n\n\n\n","category":"method"},{"location":"public/#QuantumACES.save_aces-Tuple{ACESData}","page":"Public API","title":"QuantumACES.save_aces","text":"save_aces(aces_data::ACESData; clear_design::Bool = false)\n\nSaves the ACES data aces_data with the appropriate filename, and deletes the design file if it exists and clear_design is true.\n\n\n\n\n\n","category":"method"},{"location":"public/#QuantumACES.save_design-Tuple{Design}","page":"Public API","title":"QuantumACES.save_design","text":"save_design(d::Design)\n\nSaves the design d with the appropriate filename.\n\n\n\n\n\n","category":"method"},{"location":"public/#QuantumACES.save_scaling-Tuple{T} where T<:AbstractScalingData","page":"Public API","title":"QuantumACES.save_scaling","text":"save_scaling(scaling_data::AbstractScalingData)\n\nSaves the scaling data scaling_data with the appropriate filename.\n\n\n\n\n\n","category":"method"},{"location":"public/#QuantumACES.scaling_filename-Union{Tuple{U}, Tuple{T}, Tuple{T, U, Int64, Vector{Int64}, Symbol}} where {T<:AbstractCircuitParameters, U<:AbstractNoiseParameters}","page":"Public API","title":"QuantumACES.scaling_filename","text":"scaling_filename(scaling_data::AbstractScalingData)\nscaling_filename(d::Design, ls_type::Symbol)\nscaling_filename(circuit_param::AbstractCircuitParameters, noise_param::AbstractNoiseParameters, tuple_number::Int, repeat_numbers::Vector{Int}, ls_type::Symbol)\n\nReturns a string describing the filename for the scaling data corresponding to the supplied design data.\n\n\n\n\n\n","category":"method"},{"location":"#QuantumACES.jl","page":"Home","title":"QuantumACES.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"QuantumACES.jl is a package for designing and simulating scalable and performant Pauli noise characterisation experiments for stabiliser circuits with averaged circuit eigenvalue sampling (ACES). It is particularly interested in characterising the noise associated with fault-tolerant gadgets in the context of topological quantum error correcting codes, such as surface code syndrome extraction circuits.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The methods used in this package are detailed in arXiv:2404.06545, and the code generating the data for this paper can be found in the scalable_aces folder on the scalable_aces branch. These methods build on the original ACES protocol presented in arXiv:2108.05803. This package relies on Stim for stabiliser circuit simulations.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The Package Guide describes how to start using QuantumACES.jl.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The Public API section documents the public functions and types of QuantumACES.jl.","category":"page"},{"location":"internal/tuples/","page":"tuples.jl","title":"tuples.jl","text":"CollapsedDocStrings = true","category":"page"},{"location":"internal/tuples/#tuples.jl","page":"tuples.jl","title":"tuples.jl","text":"","category":"section"},{"location":"internal/tuples/#Public-functions","page":"tuples.jl","title":"Public functions","text":"","category":"section"},{"location":"internal/tuples/","page":"tuples.jl","title":"tuples.jl","text":"Modules = [QuantumACES]\nPages = [\"tuples.jl\"]\nPrivate = false","category":"page"},{"location":"internal/tuples/#QuantumACES.TupleSetData-internal-tuples","page":"tuples.jl","title":"QuantumACES.TupleSetData","text":"TupleSetData\n\nData parameterising a tuple set.\n\nFields\n\ntuple_set::Vector{Vector{Int}}: The main tuple set, whose tuples are not repeated.\nrepeat_tuple_set::Vector{Vector{Int}}: The repeated tuple set, whose tuples are repeated repeat_numbers times.\nrepeat_numbers::Vector{Int}: The number of repetitions for each tuple in the repeated tuple set repeat_tuple_set.\nrepeat_indices::Vector{Int}: Indexes the repetition number in repeat_numbers that describes the number of repetitions for each tuple in repeat_tuple_set.\n\n\n\n\n\n","category":"type"},{"location":"internal/tuples/#QuantumACES.get_basic_tuple_set-Tuple{T} where T<:AbstractCircuit-internal-tuples","page":"tuples.jl","title":"QuantumACES.get_basic_tuple_set","text":"get_basic_tuple_set(c::AbstractCircuit)\n\nReturns the basic tuple set for the circuit c.\n\n\n\n\n\n","category":"method"},{"location":"internal/tuples/#QuantumACES.get_tuple_set-Tuple{TupleSetData}-internal-tuples","page":"tuples.jl","title":"QuantumACES.get_tuple_set","text":"get_tuple_set(tuple_set_data::TupleSetData)\n\nReturns the tuple set corresponding to the data tuple_set_data.\n\n\n\n\n\n","category":"method"},{"location":"internal/tuples/#QuantumACES.get_tuple_set_data-Union{Tuple{T}, Tuple{T, Vector{Vector{Int64}}}} where T<:AbstractCircuit-internal-tuples","page":"tuples.jl","title":"QuantumACES.get_tuple_set_data","text":"get_tuple_set_data(c::AbstractCircuit; init_scaling::Float64 = 0.2)\nget_tuple_set_data(c::AbstractCircuit, tuple_set::Vector{Vector{Int}}; init_scaling::Float64 = 0.2)\n\nReturns the tuple set data corresponding to the circuit c, with the non-repeated tuples either being the supplied tuple_set or the basic tuple set for c. The repeat numbers are initialised to be inversely proportional to the average noise on the gates in the layers, implicitly assuming depolarising noise, scaled by a factor init_scaling which is empirically helpful.\n\n\n\n\n\n","category":"method"},{"location":"internal/tuples/#Private-functions","page":"tuples.jl","title":"Private functions","text":"","category":"section"},{"location":"internal/tuples/","page":"tuples.jl","title":"tuples.jl","text":"Modules = [QuantumACES]\nPages = [\"tuples.jl\"]\nPublic = false","category":"page"},{"location":"internal/tuples/#QuantumACES.get_basic_experiment_numbers-Tuple{T} where T<:AbstractCircuit","page":"tuples.jl","title":"QuantumACES.get_basic_experiment_numbers","text":"get_basic_experiment_numbers(c::AbstractCircuit)\n\nReturns the experiment numbers corresponding to the basic tuple set for the circuit c.\n\n\n\n\n\n","category":"method"},{"location":"internal/tuples/#QuantumACES.get_basic_times_harm_mean-Tuple{T} where T<:AbstractCircuit","page":"tuples.jl","title":"QuantumACES.get_basic_times_harm_mean","text":"get_basic_times_harm_mean(c::AbstractCircuit)\n\nReturns the harmonic mean of the experiment times corresponding to the basic tuple set for the circuit c.\n\n\n\n\n\n","category":"method"},{"location":"internal/tuples/#QuantumACES.get_tuple_set_params-Union{Tuple{T}, Tuple{T, Vector{Vector{Int64}}, Vector{Int64}}} where T<:AbstractCircuit","page":"tuples.jl","title":"QuantumACES.get_tuple_set_params","text":"get_tuple_set_params(c::AbstractCircuit, tuple_set::Vector{Vector{Int}}, experiment_numbers::Vector{Int})\n\nReturns the time taken to implement each tuple tuple_times and the default shot weights for each tuple shot_weights corresponding to the circuit c with the tuple set tuple_set and the experiment numbers experiment_numbers.\n\n\n\n\n\n","category":"method"}]
}
